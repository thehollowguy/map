-- Stellaris Strategic AI (Stockfish-style scalar evaluation)
-- Design goals:
-- 1) Single scalar score for empire state
-- 2) Phase-aware weights (early/mid/late)
-- 3) Risk-aware and monotonic-in-good-signals behavior
-- 4) Adaptive fleet/tech meta with inertia (no thrashing)

local StratAI = {}
StratAI.__index = StratAI

local PHASE = {
    EARLY = "early",
    MID = "mid",
    LATE = "late"
}

local CRISIS_PHASE_ORDER = { none = 0, active = 1, peak = 2, waning = 3, defeated = 4 }

local META_TABLE = {
    {
        phase = PHASE.EARLY,
        signature_conditions = {
            game_year_max = 2210,
            net_alloys_pp_min = 4.0,
            tech_tier_rel_max = 1.05,
            hostile_neighbors_ratio_max = 0.25,
            planet_count_max = 8
        },
        strategy_name = "standard_research_tall",
        weight_modifiers = { Tech = 1.30, Eco = 1.15, Mil = 0.80, Pos = 0.90 },
        hard_guardrails = { no_declare_war = true },
        confidence = 0.93
    },
    {
        phase = PHASE.EARLY,
        signature_conditions = {
            game_year_max = 2215,
            influence_income_min = 4.5,
            net_alloys_pp_min = 5.0,
            chokepoints_owned_ratio_min = 0.4
        },
        strategy_name = "chokepoint_rush",
        weight_modifiers = { Pos = 1.45, Mil = 1.25, Eco = 0.85, Tech = 0.95 },
        confidence = 0.89
    },
    {
        phase = PHASE.MID,
        signature_conditions = {
            game_year_min = 2220,
            game_year_max = 2260,
            net_alloys_pp_min = 8.0,
            naval_cap_usage_ratio_max = 0.70
        },
        strategy_name = "alloy_snowball_mega_shipyard",
        weight_modifiers = { Mil = 1.40, Eco = 1.20, Tech = 0.90 },
        confidence = 0.91
    },
    {
        phase = PHASE.LATE,
        signature_conditions = {
            game_year_min = 2260,
            crisis_proximity_min = 0.6,
            crisis_phase = "none",
            repeatables_unlocked = true,
            naval_cap_used_ratio_min = 0.85
        },
        strategy_name = "crisis_fortress_prep",
        weight_modifiers = { Mil = 1.70, Pos = 1.50, Eco = 1.10, Risk = 0.60 },
        hard_guardrails = { no_declare_war = true },
        confidence = 0.94
    },
    {
        phase = "any",
        signature_conditions = {
            game_year_min = 2230,
            bio_ascension = true,
            pop_growth_pressure_min = 0.58,
            planet_capacity_pressure_min = 0.50
        },
        strategy_name = "bio_genesis_bio_rush",
        weight_modifiers = { Mil = 1.45, Eco = 1.20, Tech = 0.95, Risk = 0.70 },
        confidence = 0.90
    },
    {
        phase = "any",
        signature_conditions = {
            game_year_min = 2235,
            machine_age_virtuality = true,
            net_energy_pp_min = 6.0,
            tech_tier_rel_min = 1.05
        },
        strategy_name = "machine_age_virtual_scale",
        weight_modifiers = { Tech = 1.55, Eco = 1.30, Mil = 0.90 },
        confidence = 0.89
    },
    {
        phase = PHASE.EARLY,
        signature_conditions = {
            game_year_max = 2230,
            shattered_ring_origin = true,
            alloy_density_min = 0.55
        },
        strategy_name = "shattered_ring_recovery",
        weight_modifiers = { Eco = 1.35, Tech = 1.20, Mil = 0.85 },
        confidence = 0.86
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_phase_min = "active",
            our_fleet_crisis_ratio_min = 1.2,
            crisis_strength_max = 0.4,
            enemy_crisis_fleet_ratio_max = 0.3
        },
        strategy_name = "crisis_alpha_strike",
        weight_modifiers = { Mil = 2.00, Risk = 0.40, Pos = 1.40 },
        confidence = 0.90
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_type = "unbidden",
            our_fleet_crisis_ratio_min = 0.9,
            arc_emitter_tech_unlocked = true
        },
        strategy_name = "unbidden_arc_counter",
        weight_modifiers = { Tech = 1.60, Mil = 1.80 },
        confidence = 0.88
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_type = "contingency",
            pd_tech_unlocked = true,
            enemy_crisis_fleet_ratio_max = 0.5
        },
        strategy_name = "contingency_pd_swarm",
        weight_modifiers = { Mil = 1.90, Pos = 1.60 },
        confidence = 0.92
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_type = "scourge",
            tracking_tech_unlocked = true,
            strike_craft_tech_unlocked = true
        },
        strategy_name = "scourge_tracking_hunter",
        weight_modifiers = { Mil = 1.85, Tech = 1.40 },
        confidence = 0.87
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_phase_min = "peak",
            our_fleet_crisis_ratio_max = 0.7,
            net_alloys_min = -10,
            enemy_crisis_fleet_ratio_max = 0.2
        },
        strategy_name = "crisis_sustain_fallback",
        weight_modifiers = { Eco = 2.00, Stab = 1.80, Mil = 0.70 },
        hard_guardrails = { no_offensive_war = true, no_colonize = true },
        confidence = 0.95
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_phase = "waning",
            our_fleet_crisis_ratio_min = 1.5,
            enemy_power_rel_max = 0.6,
            border_seal_opportunity_min = 0.7
        },
        strategy_name = "post_crisis_carveup",
        weight_modifiers = { Mil = 2.20, Pos = 1.90, Risk = 0.30 },
        confidence = 0.93
    },
    {
        phase = "any",
        signature_conditions = {
            crisis_phase = "defeated",
            crisis_killer = "us",
            enemy_power_rel_max = 0.4,
            unity_per_month_min = 100
        },
        strategy_name = "crisis_victory_ascension",
        weight_modifiers = { Tech = 1.70, Stab = 1.50, Eco = 1.30 },
        confidence = 0.96
    }
}


local COUNTER_META_TABLE = {
    {
        opponent_signature_conditions = {
            game_year_min = 2230,
            enemy_bio_ascension = true,
            enemy_pop_growth_pressure_min = 0.60,
            enemy_ship_class_corvette_min = 0.40
        },
        our_strategy_name = "bio_swarm_counter",
        our_weight_modifiers = { Mil = 1.75, Pos = 1.25, Eco = 1.05 },
        our_priority_boost_actions = { "redesign_fleet_pd_swarm", "fortify_chokepoints_heavy", "economic_raid" },
        doctrine_override = "anti_evasion",
        confidence = 0.90
    },
    {
        opponent_signature_conditions = {
            game_year_min = 2235,
            enemy_machine_age_virtuality = true,
            enemy_research_pp_min = 14.0,
            enemy_planet_count_max = 7
        },
        our_strategy_name = "virtuality_denial",
        our_weight_modifiers = { Mil = 1.60, Tech = 1.20, Pos = 1.20 },
        our_priority_boost_actions = { "declare_tech_denial_war", "probe_skirmish_habitats", "embargo_hegemon" },
        doctrine_override = "anti_shield",
        confidence = 0.88
    },
    {
        opponent_signature_conditions = {
            game_year_max = 2235,
            enemy_shattered_ring_origin = true,
            enemy_starbase_count_min = 12,
            enemy_chokepoints_owned_ratio_min = 0.55
        },
        our_strategy_name = "ring_denial_raids",
        our_weight_modifiers = { Mil = 1.45, Risk = 0.65, Pos = 1.30 },
        our_priority_boost_actions = { "economic_raid", "multi_front_raid", "tech_denial" },
        doctrine_override = "anti_armor",
        confidence = 0.86
    },
    {
        opponent_signature_conditions = {
            game_year_max = 2220,
            enemy_research_pp_min = 12.0,
            enemy_planet_count_max = 6,
            enemy_habitat_count_min = 2,
            tech_tier_rel_min = 1.15
        },
        our_strategy_name = "disrupt_tall_tech",
        our_weight_modifiers = { Mil = 1.65, Risk = 0.45, Pos = 1.35, Tech = 0.85 },
        our_priority_boost_actions = { "declare_tech_denial_war", "redesign_fleet_corvette_swarm", "probe_skirmish_habitats", "build_starbase_chokepoint" },
        doctrine_override = "anti_evasion",
        bottleneck_override_suggestion = "naval_cap",
        confidence = 0.92
    },
    {
        opponent_signature_conditions = {
            game_year_max = 2215,
            enemy_planet_count_min = 12,
            enemy_chokepoints_owned_ratio_min = 0.65,
            enemy_starbase_count_min = 15
        },
        our_strategy_name = "overextend_bait",
        our_weight_modifiers = { Mil = 1.50, Pos = 1.55, Eco = 0.90 },
        our_priority_boost_actions = { "build_skirmish_fleets", "bait_overextension", "seal_borders_counter", "vassalize_minor_neighbors" },
        doctrine_override = "anti_corvette",
        confidence = 0.88
    },
    {
        opponent_signature_conditions = {
            game_year_min = 2225,
            game_year_max = 2270,
            enemy_alloy_per_pop_min = 10.0,
            enemy_mega_shipyard_count_min = 1,
            enemy_fleet_power_growth_min = 0.25
        },
        our_strategy_name = "attrition_grind",
        our_weight_modifiers = { Mil = 1.75, Pos = 1.70, Risk = 0.55 },
        our_priority_boost_actions = { "redesign_fleet_artillery_line", "fortify_chokepoints_heavy", "strike_supply_lines", "build_fortress_worlds" },
        doctrine_override = "anti_armor",
        bottleneck_override_suggestion = "alloys",
        confidence = 0.91
    },
    {
        opponent_signature_conditions = {
            enemy_has_battleships = true,
            enemy_ship_class_battleship_min = 0.50,
            our_tech_tier_rel_max = 0.95,
            enemy_range_bias_min = 0.60
        },
        our_strategy_name = "pd_corvette_swarm",
        our_weight_modifiers = { Mil = 1.80, Tech = 1.20 },
        our_priority_boost_actions = { "rush_pd_corvettes", "research_repeatable_pd", "redesign_fleet_pd_swarm", "skirmish_alpha_strike" },
        doctrine_override = "anti_artillery",
        confidence = 0.90
    },
    {
        opponent_signature_conditions = {
            crisis_proximity_min = 0.7,
            enemy_strategic_coordination_center = true,
            enemy_chokepoint_coverage_min = 0.80,
            enemy_fortress_worlds_min = 3
        },
        our_strategy_name = "preempt_turtle_crack",
        our_weight_modifiers = { Mil = 2.00, Risk = 0.35, Pos = 1.60 },
        our_priority_boost_actions = { "total_war_pre_crisis", "vassal_swarm_rivals", "tech_denial_fortress", "build_mega_shipyard_rush" },
        confidence = 0.87
    },
    {
        opponent_signature_conditions = {
            enemy_missile_usage_min = 0.55,
            enemy_pd_strength_min = 0.60,
            enemy_ship_class_corvette_min = 0.45
        },
        our_strategy_name = "artillery_bypass",
        our_weight_modifiers = { Mil = 1.70, Tech = 1.30 },
        our_priority_boost_actions = { "redesign_fleet_long_range_artillery", "research_neutron_launchers", "build_battleship_line", "kiting_doctrine" },
        doctrine_override = "anti_missile",
        confidence = 0.89
    },
    {
        opponent_signature_conditions = {
            enemy_evasion_bias_min = 0.60,
            enemy_ship_class_corvette_min = 0.70,
            enemy_tracking_weak = true
        },
        our_strategy_name = "tracking_battleship_wall",
        our_weight_modifiers = { Mil = 1.85, Eco = 1.10 },
        our_priority_boost_actions = { "research_repeatable_tracking", "redesign_fleet_battleship_tracking", "build_carrier_support", "chokepoint_ambush" },
        doctrine_override = "anti_evasion",
        confidence = 0.88
    },
    {
        opponent_signature_conditions = {
            enemy_megastructures_online_min = 2,
            enemy_megastructures_in_progress_min = 1,
            our_megastructures_online_max = 1
        },
        our_strategy_name = "sabotage_mega_race",
        our_weight_modifiers = { Risk = 1.50, Mil = 1.60, Tech = 1.40 },
        our_priority_boost_actions = { "espionage_sabotage_mega", "declare_mega_denial_war", "build_hyper_relay_network", "steal_tech_mega" },
        confidence = 0.85
    }
}

local PHASE_WEIGHTS = {
    early = { Eco = 0.40, Mil = 0.10, Tech = 0.15, Stab = 0.20, Pos = 0.15, Risk = 0.20 },
    mid   = { Eco = 0.30, Mil = 0.25, Tech = 0.20, Stab = 0.10, Pos = 0.15, Risk = 0.25 },
    late  = { Eco = 0.20, Mil = 0.35, Tech = 0.25, Stab = 0.05, Pos = 0.10, Risk = 0.30 }
}

local MEGASTRUCTURE_PRIORITY = {
    "Mega Shipyard",
    "Dyson Sphere",
    "Matter Decompressor",
    "Strategic Coordination Center",
    "Science Nexus",
    "Ring World"
}

local ROLE = {
    GENERATOR = "Generator World",
    MINING = "Mining World",
    AGRI = "Agri World",
    INDUSTRIAL = "Industrial World",
    RESEARCH = "Research World",
    FORTRESS = "Fortress World",
    TRADE = "Trade World",
    ECU_CANDIDATE = "Ecumenopolis Candidate",
    BALANCED = "Balanced"
}

local function clamp(value, min_v, max_v)
    if value < min_v then return min_v end
    if value > max_v then return max_v end
    return value
end

local function safe_number(value, fallback)
    if type(value) ~= "number" then return fallback end
    return value
end

local function deep_copy(tbl)
    local out = {}
    for k, v in pairs(tbl or {}) do
        if type(v) == "table" then
            out[k] = deep_copy(v)
        else
            out[k] = v
        end
    end
    return out
end

local function merge_config(user)
    local defaults = {
        colonize_habitability_floor = 60,
        colonize_size_floor = 14,
        megastructure_alloy_surplus_floor = 200,
        inertia = 0.85,
        war_horizon_months = 24,
        action_horizon_years = 3,
        risk_uncertainty_penalty = 0.05,
        score_clip = 10.0,
        doctrine_confirmations_required = 3,
        doctrine_retry_cooldown = 2,
        war_loss_tolerance = 0.35,
        crisis_deficit_tolerance = 0.25,
        irreversibility_phase_weight = { early = 1.0, mid = 0.8, late = 0.6 },
        trend_sensitivity = { positive = 0.12, negative = 0.25 },
        closure_thresholds = {
            eco_surplus_per_pop = 2.0,
            military_advantage = 0.6,
            tech_parity_floor = 1.0
        },
        self_critique_period_years = 5,
        confidence_bounds = { min = 0.7, max = 1.25 },
        curiosity = {
            enabled = true,
            uncertainty_trigger = 0.55,
            low_cost_limit = 0.35,
            stagnation_window = 5,
            stagnation_epsilon = 0.05,
            desperation_bonus = 0.25,
            exploration_share = 0.20,
            max_eval_share = 0.08,
            phase_modifier = { early = 1.0, mid = 0.7, late = 0.35 },
            winning_uncurious_threshold = 0.75,
            fragile_economy_block = true,
            plan_lock_block = true,
            irreversible_downside_block = true,
            domain_decay = 0.65
        },
        ml_advisory = {
            enabled = true,
            max_weight_delta = 0.05,
            max_risk_delta = 0.03,
            remote_endpoint = nil,
            remote_enabled = false,
            remote_timeout_s = 2
        },
        fleet = {
            max_battleship_ratio = 0.35,
            min_corvette_ratio = 0.20
        },
        telemetry = {
            eval_component_log_size = 64
        },
        compatibility = {
            nsc2_compat = false,
            acot_compat = false,
            gigastructures_compat = false,
            ui_overhaul_dynamic_compat = false,
            disable_hyper_relay_spam = true,
            disable_xeno_compat_opt_in = false,
            disable_eternal_vigilance_opt_in = false
        },
        strategic = {
            closure_confidence = 0.75,
            break_rule_window_years = 8,
            volatility_leverage = 0.12,
            action_advantage_margin = 0.06,
            cg_deficit_limit = -8,
            cg_deficit_max_months = 12,
            doctrine_pivot_threshold = -0.35,
            survivable_energy_floor = -20,
            survivable_cg_floor = -12,
            survivable_stability_floor = 0.35,
            future_priority = 0.92,
            commitment_window_bonus = 0.40,
            campaign_horizon_years = 8,
            logistics_weight = 0.30,
            opportunity_window_boost = 0.35,
            diplomatic_manipulation_weight = 0.18,
            long_horizon_weight = 0.22,
            war_termination_margin = 0.12,
            profile_adaptation_weight = 0.18,
            deception_weight = 0.12,
            crisis_prep_weight = 0.22,
            patience_years = 10,
            tech_anticipation_weight = 0.16,
            anti_snowball_weight = 0.20,
            crisis_total_war_eta = 24,
            sacrifice_weight = 0.28,
            fallback_line_weight = 0.22
        },
        clausewitz = {
            projection_months = { 12, 24, 36 },
            uncertainty_band = 0.15,
            bottleneck_rescan_months = 6,
            doctrine_confidence_threshold = 3
        },
        priority_bias = {
            early = { economy = 1.00, stability = 0.85, military = 0.60, tech = 0.70 },
            mid = { economy = 0.90, stability = 0.70, military = 0.85, tech = 0.80 },
            late = { economy = 0.65, stability = 0.55, military = 1.00, tech = 0.95 }
        },
        friend_mode = {
            enabled = false,
            rescue_survival_threshold = 0.28,
            rescue_success_threshold = 0.58,
            protective_ignorance = 0.10,
            support_weight = 0.35
        },
        aggression_slider = 1.0,
        difficulty_profile = {
            eco_bias = 1.0,
            tech_bias = 1.0,
            mil_bias = 1.0,
            curiosity_enabled = true
        },
        personality = {
            enabled = true,
            archetype_variance = 1.0
        },
        performance = {
            low_difficulty_threshold = 0.65,
            max_projection_months_low_diff = 24,
            cap_branching_low_diff = true
        }
    }

    local cfg = deep_copy(defaults)
    for k, v in pairs(user or {}) do
        cfg[k] = v
    end
    return cfg
end

local function normalize_ratio(v)
    return clamp(safe_number(v, 0), 0.0, 1.0)
end

local function logistic_like(x, scale)
    local s = safe_number(scale, 1.0)
    local z = safe_number(x, 0) / s
    return z / (1 + math.abs(z))
end

local function deficit_penalty(x)
    -- Exponential-like penalty for negative resources.
    if x >= 0 then return 0 end
    local mag = math.abs(x)
    return (mag * mag) / (1 + mag)
end

local function weighted_sum(a, b)
    local sum = 0
    for k, v in pairs(a or {}) do
        sum = sum + (safe_number(v, 0) * safe_number((b or {})[k], 0))
    end
    return sum
end

local function blend(old_v, new_v, inertia)
    local i = clamp(safe_number(inertia, 0.85), 0.0, 0.999)
    return old_v * i + new_v * (1.0 - i)
end

local function civics_has(state, key)
    for _, c in ipairs((state.civics or {})) do
        if c == key then return true end
    end
    return false
end

local function ethics_has(state, key)
    for _, e in ipairs((state.ethics or {})) do
        if e == key then return true end
    end
    return false
end

function StratAI.new(config)
    local self = setmetatable({}, StratAI)
    self.config = merge_config(config)

    self.enemy_models = {}
    self.galaxy_meta = {
        avg_tech_tier = 1,
        dominant_ship_class = "corvette",
        dominant_damage_type = "mixed",
        crisis_phase = "none",
        total_wars_active = 0
    }

    self.last_eval = nil
    self.current_plan = nil
    self.matchup_memory = {}
    self.pending_doctrine = nil
    self.doctrine_confirmation_count = 0
    self.current_doctrine = "balanced"
    self.failed_doctrines = {}
    self.doctrine_cooldowns = {}
    self.metric_history = {}
    self.heuristic_confidence = {
        irreversibility = 1.0,
        trajectory = 1.0,
        closure = 1.0
    }
    self.last_self_critique_year = nil
    self.eval_history = {}
    self.curiosity_memory = {
        counters = 1.0,
        diplomacy = 1.0,
        skirmish = 1.0
    }
    self.ml_advisory = {
        weight_delta = { Eco = 0, Mil = 0, Tech = 0, Stab = 0, Pos = 0, Risk = 0 },
        risk_delta = 0,
        confidence = 1.0
    }
    self.empire_identity = "balanced_power"
    self.failure_clocks = {}
    self.enemy_mind_models = {}
    self.decision_memory = {}
    self.domain_confidence = { economy = 1.0, military = 1.0, technology = 1.0, diplomacy = 1.0 }
    self.clausewitz_memory = {
        bottleneck = { key = nil, months_locked = 0 },
        doctrine_flags = {},
        confidence_counters = {}
    }
    self.campaign_memory = { outcomes = {}, active_plan = "economic_boom", meta = { losses = {}, spikes = {}, collapses = {} } }
    self.player_profile = { years_observed = 0, rush = 0.5, turtle = 0.5, tech_greedy = 0.5, diplomacy = 0.5, fleet_overbuild = 0.5, border_neglect = 0.5, archetype = "Opportunist" }
    self.strategic_memory = { grudges = {}, patience_targets = {}, coalition_targets = {}, strongest_empire = nil }
    self.friend_state = { intent = { goal = "economy", risk = 0.4, attention = "core" }, notices = {}, rescue_cooldown = 0 }
    self.strongest_meta = nil
    self.meta_hysteresis = { strategy = nil, lock = 0 }
    self.active_counter_meta = nil
    self.opponent_meta_confidence = 0
    self.meta_effectiveness = { by_meta = {}, by_counter = {} }
    self.eval_component_log = {}
    self.ml_advisory_remote_status = { last_sync_year = nil, status = "idle" }

    return self
end

function StratAI:_project_months_to_failure(stock, monthly_income, monthly_burn, emergency_floor)
    local s = math.max(0, safe_number(stock, 0))
    local net = safe_number(monthly_income, 0) - safe_number(monthly_burn, 0)
    local floor = math.max(0, safe_number(emergency_floor, 0))
    if net >= 0 then return 999 end
    return clamp((s - floor) / math.abs(net), 0, 999)
end

function StratAI:global_irreversibility_trigger(state)
    local c = self.config.clausewitz or {}
    local uncertainty = 1 + safe_number(c.uncertainty_band, 0.15)

    local econ_mtf = self:_project_months_to_failure(
        safe_number(state.energy_stockpile, 0) + safe_number(state.cg_stockpile, 0),
        safe_number(state.net_energy, 0) + safe_number(state.net_consumer_goods, 0),
        safe_number(state.energy_burn, 0) + safe_number(state.cg_burn, 0),
        0
    ) / uncertainty

    local mil_mtf = self:_project_months_to_failure(
        safe_number(state.alloy_stockpile, 0),
        safe_number(state.net_alloys, 0),
        safe_number(state.projected_war_alloy_burn, 0),
        safe_number(state.alloy_reserve_floor, 0)
    ) / uncertainty

    local tech_mtf = self:_project_months_to_failure(
        safe_number(state.research_backlog, 0),
        safe_number(state.total_research, 0),
        safe_number(state.enemy_total_research, 0),
        0
    ) / uncertainty

    local shortest = math.min(econ_mtf, mil_mtf, tech_mtf)
    local penalty = 0
    if shortest <= 12 then penalty = 1.0
    elseif shortest <= 24 then penalty = 0.65
    elseif shortest <= 36 then penalty = 0.35 end

    return penalty, { economy = econ_mtf, military = mil_mtf, tech = tech_mtf, shortest = shortest }
end

function StratAI:update_bottleneck_override(state)
    local lock = self.clausewitz_memory.bottleneck
    local rescan = safe_number((self.config.clausewitz or {}).bottleneck_rescan_months, 6)
    if lock.months_locked <= 0 or not lock.key or lock.months_locked % rescan == 0 then
        local key = select(1, self:detect_bottleneck(state))
        lock.key = key
    end
    lock.months_locked = math.max(0, safe_number(lock.months_locked, 0) + 1)
    if safe_number(state.monthly_tick, 0) % rescan == 0 then
        lock.months_locked = 0
    end
    self.clausewitz_memory.bottleneck = lock
    return lock.key
end

function StratAI:update_doctrine_bucket(enemy_id, model)
    local conf = self.clausewitz_memory.confidence_counters[enemy_id] or { value = 0 }
    local flags = self.clausewitz_memory.doctrine_flags[enemy_id] or {
        enemy_missile_heavy = false,
        enemy_corvette_swarm = false,
        enemy_artillery_line = false
    }
    conf.value = clamp(conf.value + 1, 0, 8)
    local threshold = safe_number((self.config.clausewitz or {}).doctrine_confidence_threshold, 3)

    if conf.value >= threshold then
        flags.enemy_missile_heavy = safe_number(model.missile_usage, 0) >= 0.55
        flags.enemy_corvette_swarm = safe_number(model.ship_class_corvette, 0) >= 0.55
        flags.enemy_artillery_line = safe_number(model.ship_class_battleship, 0) >= 0.45 and safe_number(model.range_bias, 0) >= 0.55
    end

    conf.value = math.max(0, conf.value - 0.10) -- monthly confidence decay
    self.clausewitz_memory.confidence_counters[enemy_id] = conf
    self.clausewitz_memory.doctrine_flags[enemy_id] = flags
    return flags, conf.value
end

function StratAI:_phase_priority_bias(phase)
    local p = self.config.priority_bias or {}
    return p[phase] or p.mid or { economy = 1, stability = 1, military = 1, tech = 1 }
end

function StratAI:_get_matchup_memory(enemy_id)
    if not self.matchup_memory[enemy_id] then
        self.matchup_memory[enemy_id] = {
            shield_bias = 0,
            armor_bias = 0,
            evasion_bias = 0,
            missile_bias = 0,
            strike_craft_bias = 0,
            aggression_bias = 0,
            econ_focus = 0,
            confirmations = 0
        }
    end
    return self.matchup_memory[enemy_id]
end

-- ############################################################
-- 1) PLANETS
-- ############################################################

function StratAI:score_colonization(planet)
    local habitability = safe_number(planet.habitability, 0)
    local size = safe_number(planet.size, 0)
    local distance_cost = safe_number(planet.distance_upkeep, 0)

    local special_bonus = 0
    if planet.special_type == "relic" then special_bonus = special_bonus + 22 end
    if planet.special_type == "gaia" then special_bonus = special_bonus + 24 end
    if planet.special_type == "ring" then special_bonus = special_bonus + 25 end
    if planet.special_type == "habitat" then special_bonus = special_bonus + 8 end
    if planet.special_type == "tomb" then special_bonus = special_bonus - 8 end

    local district_quality =
        safe_number(planet.generator_cap, 0) +
        safe_number(planet.mining_cap, 0) +
        safe_number(planet.agri_cap, 0)

    local score =
        (habitability * 0.60) +
        (size * 1.8) +
        (district_quality * 0.50) +
        special_bonus -
        (distance_cost * 1.2)

    return clamp(score, -100, 300)
end

function StratAI:should_colonize(planet)
    local habitability = safe_number(planet.habitability, 0)
    local size = safe_number(planet.size, 0)
    local is_special = (planet.special_type ~= nil and planet.special_type ~= "")

    local passes_gate =
        habitability >= self.config.colonize_habitability_floor and
        (size >= self.config.colonize_size_floor or is_special)

    if not passes_gate then
        return false, "Failed baseline colonization gate"
    end

    if self:score_colonization(planet) >= 65 then
        return true, "Strong colonization target"
    end

    return false, "Colonization score below safety threshold"
end

function StratAI:assign_planet_role(planet)
    local size = safe_number(planet.size, 0)
    local gen_cap = safe_number(planet.generator_cap, 0)
    local min_cap = safe_number(planet.mining_cap, 0)
    local agri_cap = safe_number(planet.agri_cap, 0)
    local trade_cap = safe_number(planet.trade_cap, 0)
    local upkeep_pressure = normalize_ratio(planet.upkeep_pressure)

    if planet.special_type == "relic" then
        return planet.restore_ready and ROLE.ECU_CANDIDATE or ROLE.RESEARCH
    end

    if planet.special_type == "ecumenopolis" then
        return ROLE.INDUSTRIAL
    end

    if safe_number(planet.research_deposits, 0) >= 2 then
        return ROLE.RESEARCH
    end

    local max_cap = math.max(gen_cap, min_cap, agri_cap)

    if size >= 20 and max_cap >= 8 then return ROLE.INDUSTRIAL end
    if gen_cap == max_cap and gen_cap >= 5 then return ROLE.GENERATOR end
    if min_cap == max_cap and min_cap >= 5 then return ROLE.MINING end
    if agri_cap == max_cap and agri_cap >= 5 then return ROLE.AGRI end
    if trade_cap >= 8 and upkeep_pressure < 0.45 then return ROLE.TRADE end

    return ROLE.BALANCED
end

function StratAI:district_policy(planet)
    local size = safe_number(planet.size, 0)
    local role = self:assign_planet_role(planet)
    local upkeep_pressure = normalize_ratio(planet.upkeep_pressure)
    local cg_stress = normalize_ratio(planet.cg_stress)
    local energy_stress = normalize_ratio(planet.energy_stress)

    if planet.special_type == "ecumenopolis" then
        return { mode = "building_heavy", allow_agri = false, support_trade = true, notes = "No agri districts on Ecumenopolis" }
    end

    if upkeep_pressure > 0.60 or cg_stress > 0.55 or energy_stress > 0.55 then
        return { mode = "hybrid", support_trade = true, veto_over_specialization = true, notes = "Deficit-aware: add upkeep support before specialization" }
    end

    if role == ROLE.GENERATOR or role == ROLE.MINING or role == ROLE.AGRI then
        return { mode = "district_heavy", support_trade = true, matching_jobs_weight = 1.25, notes = "Specialized resource world" }
    end

    if role == ROLE.RESEARCH then
        return { mode = "building_heavy", support_trade = true, matching_jobs_weight = 1.20, notes = "Research stacking world" }
    end

    if size <= 12 then
        return { mode = "building_heavy", support_trade = true, notes = "Small planets: buildings first" }
    elseif size <= 18 then
        return { mode = "hybrid", support_trade = true, notes = "Medium planets: hybrid policy" }
    end

    return { mode = "district_heavy", support_trade = true, notes = "Large planets: district scaling first" }
end

-- ############################################################
-- 2) OPPONENT MODEL + META MEMORY
-- ############################################################

function StratAI:_empty_profile()
    return {
        evasion_bias = 0.0,
        shield_bias = 0.0,
        armor_bias = 0.0,
        hull_bias = 0.0,
        strike_craft = 0.0,
        missile_usage = 0.0,
        range_bias = 0.0,

        ship_class_corvette = 0.0,
        ship_class_cruiser = 0.0,
        ship_class_battleship = 0.0,

        tech_tier = 1.0,
        uncertainty = 1.0
    }
end

function StratAI:_did_conditions_change(enemy_id)
    local m = self.matchup_memory[enemy_id]
    if not m then return true end
    local prev = m.last_conditions
    local now = {
        shield = safe_number(m.shield_bias, 0),
        armor = safe_number(m.armor_bias, 0),
        evasion = safe_number(m.evasion_bias, 0),
        missile = safe_number(m.missile_bias, 0)
    }
    m.last_conditions = now
    if not prev then return true end
    local delta = math.abs(now.shield-prev.shield)+math.abs(now.armor-prev.armor)+math.abs(now.evasion-prev.evasion)+math.abs(now.missile-prev.missile)
    return delta >= 0.20
end

function StratAI:record_failed_doctrine(enemy_id, doctrine)
    if not enemy_id or not doctrine then return end
    if not self.failed_doctrines[enemy_id] then self.failed_doctrines[enemy_id] = {} end
    if not self.doctrine_cooldowns[enemy_id] then self.doctrine_cooldowns[enemy_id] = {} end
    self.failed_doctrines[enemy_id][doctrine] = safe_number(self.failed_doctrines[enemy_id][doctrine], 0) + 1
    self.doctrine_cooldowns[enemy_id][doctrine] = safe_number(self.config.doctrine_retry_cooldown, 2)
end

function StratAI:_failed_doctrine_penalty(enemy_id, doctrine)
    local failures = (((self.failed_doctrines or {})[enemy_id] or {})[doctrine]) or 0
    local cooldown = ((((self.doctrine_cooldowns or {})[enemy_id] or {})[doctrine]) or 0)
    if failures <= 0 and cooldown <= 0 then return 0 end
    if self:_did_conditions_change(enemy_id) then return 0 end
    return math.min(0.45, failures * 0.12 + cooldown * 0.06)
end

function StratAI:update_opponent_model(enemy_id, observation)
    local old = self.enemy_models[enemy_id] or self:_empty_profile()
    local obs = observation or {}
    local i = self.config.inertia

    local new_model = {
        evasion_bias = blend(old.evasion_bias, normalize_ratio(obs.evasion_bias), i),
        shield_bias = blend(old.shield_bias, normalize_ratio(obs.shield_bias), i),
        armor_bias = blend(old.armor_bias, normalize_ratio(obs.armor_bias), i),
        hull_bias = blend(old.hull_bias, normalize_ratio(obs.hull_bias), i),
        strike_craft = blend(old.strike_craft, normalize_ratio(obs.strike_craft), i),
        missile_usage = blend(old.missile_usage, normalize_ratio(obs.missile_usage), i),
        range_bias = blend(old.range_bias, normalize_ratio(obs.range_bias), i),

        ship_class_corvette = blend(old.ship_class_corvette, normalize_ratio(obs.ship_class_corvette), i),
        ship_class_cruiser = blend(old.ship_class_cruiser, normalize_ratio(obs.ship_class_cruiser), i),
        ship_class_battleship = blend(old.ship_class_battleship, normalize_ratio(obs.ship_class_battleship), i),

        tech_tier = blend(old.tech_tier, safe_number(obs.tech_tier, old.tech_tier), i),
        uncertainty = blend(old.uncertainty, safe_number(obs.uncertainty, 0.5), i)
    }

    self.enemy_models[enemy_id] = new_model

    local m = self:_get_matchup_memory(enemy_id)
    m.shield_bias = blend(m.shield_bias, new_model.shield_bias, self.config.inertia)
    m.armor_bias = blend(m.armor_bias, new_model.armor_bias, self.config.inertia)
    m.evasion_bias = blend(m.evasion_bias, new_model.evasion_bias, self.config.inertia)
    m.missile_bias = blend(m.missile_bias, new_model.missile_usage, self.config.inertia)
    m.strike_craft_bias = blend(m.strike_craft_bias, new_model.strike_craft, self.config.inertia)
    m.aggression_bias = blend(m.aggression_bias, normalize_ratio(obs.aggression_bias), self.config.inertia)
    m.econ_focus = blend(m.econ_focus, normalize_ratio(obs.econ_focus), self.config.inertia)
    m.confirmations = math.min(12, safe_number(m.confirmations, 0) + 1)

    local doctrine_flags, doctrine_conf = self:update_doctrine_bucket(enemy_id, new_model)
    m.doctrine_flags = doctrine_flags
    m.doctrine_confidence = doctrine_conf

    return new_model
end

function StratAI:recommended_counter_bias(enemy_id)
    local m = self:_get_matchup_memory(enemy_id)
    return {
        tracking_weight = m.evasion_bias,
        kinetic_weight = m.shield_bias,
        energy_weight = m.armor_bias,
        pd_weight = m.missile_bias,
        strike_craft_weight = m.evasion_bias * 0.5 + (1.0 - m.strike_craft_bias) * 0.2
    }
end

function StratAI:recommend_doctrine(enemy_id)
    local bias = self:recommended_counter_bias(enemy_id)
    local top_key, top_val = "kinetic_weight", -1
    for k, v in pairs(bias) do
        if v > top_val then
            top_key, top_val = k, v
        end
    end

    local doctrine = "balanced"
    if top_key == "tracking_weight" then doctrine = "anti_evasion" end
    if top_key == "kinetic_weight" then doctrine = "anti_shield" end
    if top_key == "energy_weight" then doctrine = "anti_armor" end
    if top_key == "pd_weight" then doctrine = "anti_missile" end

    -- Commitment bias / inertia: require repeated confirmations before pivoting doctrine.
    if self.pending_doctrine ~= doctrine then
        self.pending_doctrine = doctrine
        self.doctrine_confirmation_count = 1
    else
        self.doctrine_confirmation_count = self.doctrine_confirmation_count + 1
    end

    if self.doctrine_confirmation_count >= self.config.doctrine_confirmations_required then
        local penalty = self:_failed_doctrine_penalty(enemy_id, doctrine)
        if penalty > 0 then
            return self.current_doctrine, "Doctrine pivot blocked by failed-counter memory"
        end
        self.current_doctrine = doctrine
        return doctrine, "Doctrine pivot confirmed"
    end

    return self.current_doctrine or "balanced", "Insufficient confirmations for doctrine pivot"
end

function StratAI:update_galaxy_meta(meta_observation)
    local old = self.galaxy_meta
    local obs = meta_observation or {}
    local i = self.config.inertia

    local next_meta = {
        avg_tech_tier = blend(old.avg_tech_tier, safe_number(obs.avg_tech_tier, old.avg_tech_tier), i),
        dominant_ship_class = obs.dominant_ship_class or old.dominant_ship_class,
        dominant_damage_type = obs.dominant_damage_type or old.dominant_damage_type,
        crisis_phase = obs.crisis_phase or old.crisis_phase,
        total_wars_active = blend(old.total_wars_active, safe_number(obs.total_wars_active, old.total_wars_active), i)
    }

    self.galaxy_meta = next_meta
    return next_meta
end

function StratAI:compute_counter_score(our_fleet, enemy_profile)
    local our = our_fleet or {}
    local e = enemy_profile or self:_empty_profile()

    local enemy_weakness = {
        tracking = e.evasion_bias,
        anti_shield = e.shield_bias,
        anti_armor = e.armor_bias,
        pd_strength = e.missile_usage,
        alpha_damage = e.hull_bias,
        range = 1.0 - e.range_bias
    }

    local our_weakness = {
        tracking = 1.0 - normalize_ratio(safe_number(our.tracking, 0)),
        anti_shield = 1.0 - normalize_ratio(safe_number(our.anti_shield, 0)),
        anti_armor = 1.0 - normalize_ratio(safe_number(our.anti_armor, 0)),
        pd_strength = 1.0 - normalize_ratio(safe_number(our.PD_strength, 0)),
        alpha_damage = 1.0 - normalize_ratio(safe_number(our.alpha_damage, 0)),
        range = 1.0 - normalize_ratio(safe_number(our.range, 0))
    }

    local our_vector = {
        tracking = normalize_ratio(our.tracking),
        anti_shield = normalize_ratio(our.anti_shield),
        anti_armor = normalize_ratio(our.anti_armor),
        pd_strength = normalize_ratio(our.PD_strength),
        alpha_damage = normalize_ratio(our.alpha_damage),
        range = normalize_ratio(our.range)
    }

    local enemy_threat_vector = {
        tracking = e.evasion_bias,
        anti_shield = e.shield_bias,
        anti_armor = e.armor_bias,
        pd_strength = e.missile_usage,
        alpha_damage = e.hull_bias,
        range = e.range_bias
    }

    local raw = weighted_sum(our_vector, enemy_weakness) - weighted_sum(enemy_threat_vector, our_weakness)
    local normalized = clamp(logistic_like(raw, 2.5), -1.0, 1.0)

    -- Uncertainty penalty reduces confidence in counters.
    local uncertainty_penalty = safe_number(e.uncertainty, 0) * self.config.risk_uncertainty_penalty
    return clamp(normalized - uncertainty_penalty, -1.0, 1.0)
end

function StratAI:_phase_irreversibility_weight(phase)
    local w = self.config.irreversibility_phase_weight or {}
    return safe_number(w[phase], safe_number(w.mid, 0.8))
end

function StratAI:irreversibility_index(state, phase)
    local cost = 0

    -- Relative pop growth loss compounds permanently.
    local pop_diff = safe_number(state.enemy_pop_growth, 0) - safe_number(state.our_pop_growth, 0)
    if pop_diff > 0 then
        cost = cost + logistic_like(pop_diff, 2.0) * 0.35
    end

    -- Lost key chokepoints are often unrecoverable without huge war cost.
    local lost_chokepoints = math.max(0, safe_number(state.key_chokepoints_lost, 0))
    cost = cost + logistic_like(lost_chokepoints, 2.0) * 0.30

    -- Missing battleship timing while rivals have it.
    if state.enemy_has_battleships and not ((state.tech_flags or {}).battleships) then
        cost = cost + 0.35
    end

    -- Megastructure race slippage.
    local mega_gap = math.max(0, safe_number(state.enemy_megastructures_online, 0) - safe_number(state.our_megastructures_online, 0))
    cost = cost + logistic_like(mega_gap, 2.0) * 0.25

    -- Policy lockouts.
    if state.synergy_locked_out then
        cost = cost + 0.20
    end

    local phase_w = self:_phase_irreversibility_weight(phase)
    local conf = safe_number(self.heuristic_confidence.irreversibility, 1.0)
    return clamp(cost * phase_w * conf, 0, 3.0)
end

function StratAI:_update_metric_history(state)
    local h = self.metric_history
    h[#h+1] = {
        our_power = safe_number(state.our_power, 0),
        enemy_power = safe_number(state.enemy_power, 0),
        our_alloy_pp = safe_number(state.our_alloy_per_pop, 0),
        enemy_alloy_pp = safe_number(state.enemy_alloy_per_pop, 0),
        our_replace = safe_number(state.our_reinforcement_speed, 0),
        enemy_replace = safe_number(state.enemy_reinforcement_speed, 0),
        our_tech = safe_number(state.tech_tier, 1),
        enemy_tech = safe_number(state.enemy_tech_tier, 1),
        our_pop_growth = safe_number(state.our_pop_growth, 0),
        enemy_pop_growth = safe_number(state.enemy_pop_growth, 0)
    }
    if #h > 12 then table.remove(h, 1) end
end

function StratAI:trajectory_advantage()
    local h = self.metric_history
    if #h < 2 then return 0 end
    local a, b = h[#h-1], h[#h]

    local d_our = (b.our_power - a.our_power)
    local d_enemy = (b.enemy_power - a.enemy_power)
    local delta_adv = d_our - d_enemy

    local alloy_trend = (b.our_alloy_pp - a.our_alloy_pp) - (b.enemy_alloy_pp - a.enemy_alloy_pp)
    local repl_trend = (b.our_replace - a.our_replace) - (b.enemy_replace - a.enemy_replace)
    local tech_trend = (b.our_tech - a.our_tech) - (b.enemy_tech - a.enemy_tech)
    local pop_trend = (b.our_pop_growth - a.our_pop_growth) - (b.enemy_pop_growth - a.enemy_pop_growth)

    local trend =
        logistic_like(delta_adv, 1.5) * 0.35 +
        logistic_like(alloy_trend, 0.5) * 0.25 +
        logistic_like(repl_trend, 0.5) * 0.15 +
        logistic_like(tech_trend, 0.3) * 0.15 +
        logistic_like(pop_trend, 0.4) * 0.10

    local sens = self.config.trend_sensitivity or { positive = 0.12, negative = 0.25 }
    local conf = safe_number(self.heuristic_confidence.trajectory, 1.0)
    if trend >= 0 then
        return trend * safe_number(sens.positive, 0.12) * conf
    end
    return trend * safe_number(sens.negative, 0.25) * conf
end

function StratAI:_append_eval_history(value)
    self.eval_history[#self.eval_history + 1] = safe_number(value, 0)
    local max_keep = 24
    if #self.eval_history > max_keep then table.remove(self.eval_history, 1) end
end

function StratAI:curiosity_domain(action)
    if not action then return "counters" end
    if action.type == "probe_diplomacy" or action.type == "seek_vassalization" then return "diplomacy" end
    if action.type == "probe_skirmish" then return "skirmish" end
    return "counters"
end

function StratAI:decay_curiosity_domain(domain)
    local d = domain or "counters"
    local mem = self.curiosity_memory
    local factor = safe_number((self.config.curiosity or {}).domain_decay, 0.65)
    mem[d] = clamp(safe_number(mem[d], 1.0) * factor, 0.2, 1.0)
end

function StratAI:refresh_curiosity_domains()
    local mem = self.curiosity_memory
    for k, v in pairs(mem) do
        mem[k] = clamp(v + 0.03, 0.2, 1.0)
    end
end

function StratAI:fragile_economy(state)
    return safe_number(state.net_consumer_goods, 0) < 0 or safe_number(state.net_energy, 0) < 0 or safe_number(state.net_alloys, 0) <= 0
end

function StratAI:is_executing_long_plan(state)
    return state.long_term_plan_locked == true or state.megastructure_in_progress == true
end

function StratAI:is_decisively_winning(state)
    local e = safe_number((self.last_eval or {}).total, 0)
    local t = safe_number((self.config.curiosity or {}).winning_uncurious_threshold, 0.75)
    return e >= t and safe_number(state.military_advantage, 0) > 0.35 and safe_number(state.net_alloys, 0) > 0
end

function StratAI:curiosity_bonus(state, action, phase)
    local c = self.config.curiosity or {}
    if c.enabled == false then return 0, "disabled" end

    if c.fragile_economy_block and self:fragile_economy(state) then return 0, "blocked_fragile_economy" end
    if c.plan_lock_block and self:is_executing_long_plan(state) then return 0, "blocked_long_plan" end
    if self:is_decisively_winning(state) then return 0, "blocked_winning" end

    local uncertainty = normalize_ratio(state.intel_uncertainty)
    local info_gain = normalize_ratio((action and action.info_gain) or 0.55)
    local risk_tolerance = clamp(1.0 - normalize_ratio(state.projected_war_losses_alloy_ratio), 0.1, 1.0)
    risk_tolerance = risk_tolerance * self:confidence_adjusted_aggression(state)
    local phase_mod = safe_number((c.phase_modifier or {})[phase], 0.7)

    local _, cur = self:curiosity_mode(state)
    local base = uncertainty * info_gain * risk_tolerance * phase_mod
    local with_mode = base + safe_number(cur.bonus, 0) * 0.25

    local domain = self:curiosity_domain(action)
    local decay = safe_number((self.curiosity_memory or {})[domain], 1.0)
    local raw = with_mode * decay

    if c.irreversible_downside_block and normalize_ratio(state.irreversible_downside_risk) > 0.5 then
        return 0, "blocked_irreversible_risk"
    end

    local cap = safe_number(c.max_eval_share, 0.08) * safe_number(self.config.score_clip, 10.0)
    return clamp(raw, 0, cap), "ok"
end

function StratAI:detect_stagnation()
    local c = self.config.curiosity or {}
    local window = math.max(3, safe_number(c.stagnation_window, 5))
    if #self.eval_history < window then return false, 0 end

    local start_idx = #self.eval_history - window + 1
    local first = self.eval_history[start_idx]
    local last = self.eval_history[#self.eval_history]
    local slope = (last - first) / math.max(1, window - 1)
    local eps = safe_number(c.stagnation_epsilon, 0.05)

    if math.abs(slope) <= eps then
        return true, slope
    end
    return false, slope
end

function StratAI:curiosity_mode(state)
    local c = self.config.curiosity or {}
    if c.enabled == false then
        return false, { reason = "disabled", bonus = 0 }
    end

    local uncertainty = normalize_ratio(state.intel_uncertainty)
    local low_cost = normalize_ratio(state.learning_cost)
    local stagnating, slope = self:detect_stagnation()
    local ponr, _ = self:point_of_no_return(state)

    local should_explore = false
    local bonus = 0
    local reason = ""

    if uncertainty >= safe_number(c.uncertainty_trigger, 0.55) and low_cost <= safe_number(c.low_cost_limit, 0.35) then
        should_explore = true
        bonus = bonus + 0.15
        reason = "high-uncertainty low-cost scouting"
    end

    if stagnating then
        should_explore = true
        bonus = bonus + 0.10
        reason = (reason ~= "" and (reason .. " + ") or "") .. "stagnation escape"
    end

    if ponr then
        should_explore = true
        bonus = bonus + safe_number(c.desperation_bonus, 0.25)
        reason = (reason ~= "" and (reason .. " + ") or "") .. "desperation pivot"
    end

    return should_explore, { reason = reason, bonus = bonus, slope = slope }
end

function StratAI:is_exploratory_action(action)
    if not action then return false end
    if action.type == "redesign_fleet" then return true end
    if action.type == "research" and action.target == "economy_tech" then return true end
    if action.type == "tech_denial" then return true end
    if action.type == "seek_vassalization" then return true end
    return false
end

function StratAI:closure_mode_score(state)
    local pops = math.max(1, safe_number(state.pops, 1))
    local eco_pp = (safe_number(state.net_energy, 0) + safe_number(state.net_alloys, 0)) / pops
    local mil = safe_number(state.military_advantage, 0)
    local tech_parity = safe_number(state.tech_tier, 1) / math.max(1, safe_number(state.enemy_tech_tier, 1))

    local th = self.config.closure_thresholds or {}
    local ready =
        eco_pp >= safe_number(th.eco_surplus_per_pop, 2.0) and
        mil >= safe_number(th.military_advantage, 0.6) and
        tech_parity >= safe_number(th.tech_parity_floor, 1.0)

    if not ready then return 0 end

    local closure_actions = normalize_ratio(state.border_seal_opportunity) + normalize_ratio(state.vassalization_window) + normalize_ratio(state.tech_denial_window) + normalize_ratio(state.war_exhaustion_abuse_window)
    local conf = safe_number(self.heuristic_confidence.closure, 1.0)
    return clamp(logistic_like(closure_actions, 1.5) * 0.35 * conf, 0, 1.2)
end

function StratAI:self_critique(state)
    local year = safe_number(state.game_year, 0)
    if self.last_self_critique_year and (year - self.last_self_critique_year) < safe_number(self.config.self_critique_period_years, 5) then
        return nil
    end

    local h = self.metric_history
    if #h < 3 then
        self.last_self_critique_year = year
        return nil
    end

    local predicted = safe_number(state.predicted_eval_delta, 0)
    local observed = safe_number(state.observed_eval_delta, 0)
    local err = math.abs(predicted - observed)

    local bounds = self.config.confidence_bounds or { min = 0.7, max = 1.25 }
    local adjust = (err > 0.35) and -0.03 or 0.01

    for k, v in pairs(self.heuristic_confidence) do
        self.heuristic_confidence[k] = clamp(v + adjust, safe_number(bounds.min, 0.7), safe_number(bounds.max, 1.25))
    end

    self:update_ml_advisory(predicted, observed)
    self.last_self_critique_year = year
    return { error = err, adjust = adjust }
end

-- ############################################################
-- 3) STOCKFISH-STYLE EVAL
-- E = wE*Eco + wM*Mil + wT*Tech + wS*Stab + wP*Pos - wR*Risk
-- ############################################################

function StratAI:score_economy(state)
    local pops = math.max(1, safe_number(state.pops, 1))
    local planets = math.max(1, safe_number(state.planet_count, 1))

    local net_energy = safe_number(state.net_energy, 0)
    local net_minerals = safe_number(state.net_minerals, 0)
    local net_alloys = safe_number(state.net_alloys, 0)
    local net_cg = safe_number(state.net_consumer_goods, 0)

    local energy_pp = net_energy / pops
    local minerals_pp = net_minerals / pops
    local alloys_pp = net_alloys / pops
    local cg_pp = net_cg / pops

    local capacity_pp = safe_number(state.unused_district_capacity, 0) / planets
    local pop_eff = safe_number(state.pop_efficiency, 0)

    local base =
        logistic_like(energy_pp, 2.5) * 0.18 +
        logistic_like(minerals_pp, 2.5) * 0.18 +
        logistic_like(alloys_pp, 1.5) * 0.28 +
        logistic_like(cg_pp, 1.2) * 0.20 +
        logistic_like(capacity_pp, 4.0) * 0.08 +
        logistic_like(pop_eff, 1.0) * 0.08

    -- Heavy non-linear deficit penalties.
    local penalty =
        deficit_penalty(energy_pp) * 0.25 +
        deficit_penalty(minerals_pp) * 0.25 +
        deficit_penalty(alloys_pp) * 0.35 +
        deficit_penalty(cg_pp) * 0.75

    if self.galaxy_meta.crisis_phase ~= "none" then
        penalty = penalty * (1.0 - self.config.crisis_deficit_tolerance)
    end

    return clamp(base - penalty, -3.0, 3.0)
end

function StratAI:score_military(state)
    local cap_usage = normalize_ratio(state.naval_cap_usage_ratio)
    local alloy_pp = safe_number(state.net_alloys, 0) / math.max(1, safe_number(state.pops, 1))
    local ship_tier = safe_number(state.ship_tech_tier, 1)
    local gal_tier = math.max(1, safe_number(self.galaxy_meta.avg_tech_tier, 1))
    local tier_parity = ship_tier / gal_tier

    local diversity = normalize_ratio(state.fleet_diversity)
    local chokepoint = normalize_ratio(state.chokepoint_coverage)
    local border_proximity = normalize_ratio(state.border_fleet_proximity)

    local econ_negative = (safe_number(state.net_energy, 0) < 0 or safe_number(state.net_consumer_goods, 0) < 0)
    local econ_penalty = econ_negative and 0.45 or 0.0

    local enemy_counter_risk = normalize_ratio(state.enemy_counter_risk)
    local avg_ship_build_time = math.max(0.1, safe_number(state.avg_ship_build_time, 1.0))
    local shipyards_online = math.max(1, safe_number(state.shipyards_online, 1))
    local reinforcement_time = avg_ship_build_time / shipyards_online
    local reinforcement_penalty = logistic_like(reinforcement_time, 3.0) * 0.22
    local mix_score = self:_fleet_mix_score(state)

    local score =
        cap_usage * 0.20 +
        logistic_like(alloy_pp, 1.5) * 0.25 +
        logistic_like(tier_parity - 1.0, 0.5) * 0.25 +
        diversity * 0.12 +
        chokepoint * 0.12 +
        border_proximity * 0.08 +
        mix_score -
        enemy_counter_risk * 0.15 -
        reinforcement_penalty -
        econ_penalty

    return clamp(score, -3.0, 3.0)
end

function StratAI:score_tech(state)
    local pops = math.max(1, safe_number(state.pops, 1))
    local research_pp = safe_number(state.total_research, 0) / pops
    local our_tier = safe_number(state.tech_tier, 1)
    local gal_tier = math.max(1, safe_number(self.galaxy_meta.avg_tech_tier, 1))
    local parity = our_tier / gal_tier

    local flags = state.tech_flags or {}
    local key_unlock_score = 0
    key_unlock_score = key_unlock_score + (flags.battleships and 0.20 or 0)
    key_unlock_score = key_unlock_score + (flags.titans and 0.15 or 0)
    key_unlock_score = key_unlock_score + (flags.repeatables and 0.30 or 0)
    key_unlock_score = key_unlock_score + (flags.neutron_launchers and 0.16 or 0)
    key_unlock_score = key_unlock_score + (flags.arc_emitters and 0.18 or 0)
    key_unlock_score = key_unlock_score + (flags.strike_craft_3 and 0.08 or 0)
    key_unlock_score = key_unlock_score + (flags.hyper_relays and 0.05 or 0)
    key_unlock_score = key_unlock_score + (flags.gateways and 0.05 or 0)
    key_unlock_score = key_unlock_score + (flags.precursor_tech and 0.10 or 0)

    local pressure_gap_penalty = 0
    if state.enemy_has_battleships and not flags.battleships then
        pressure_gap_penalty = pressure_gap_penalty + 0.35
    end
    if state.enemy_has_repeatables and not flags.repeatables then
        pressure_gap_penalty = pressure_gap_penalty + 0.25
    end

    local crisis_alignment_bonus = 0
    if state.crisis_type == "unbidden" and flags.arc_emitters then crisis_alignment_bonus = crisis_alignment_bonus + 0.18 end
    if state.crisis_type == "contingency" and (flags.pd_3 or flags.autocannons_3) then crisis_alignment_bonus = crisis_alignment_bonus + 0.14 end
    if state.crisis_type == "scourge" and (flags.strike_craft_3 or flags.carrier_ops) then crisis_alignment_bonus = crisis_alignment_bonus + 0.12 end

    local score =
        logistic_like(research_pp, 2.0) * 0.45 +
        logistic_like(parity - 1.0, 0.5) * 0.35 +
        key_unlock_score * 0.45 +
        crisis_alignment_bonus -
        pressure_gap_penalty

    return clamp(score, -3.0, 3.0)
end

function StratAI:score_stability(state)
    local avg_stability = safe_number(state.avg_planet_stability, 50)
    local amenities = safe_number(state.amenities_surplus, 0)
    local crime = safe_number(state.avg_crime, 0)
    local faction = safe_number(state.faction_approval, 50)
    local revolt_risk = normalize_ratio(state.revolt_risk)

    local score =
        logistic_like((avg_stability - 50) / 10.0, 1.0) * 0.50 +
        logistic_like(amenities, 8.0) * 0.20 +
        logistic_like((faction - 50) / 10.0, 1.0) * 0.20 -
        logistic_like(crime, 20.0) * 0.20 -
        revolt_risk * 0.60

    if avg_stability < 40 then
        score = score - 0.60
    end
    if state.active_revolt_timer then
        score = score - 1.20
    end

    return clamp(score, -3.0, 3.0)
end

function StratAI:score_position(state)
    local chokepoints = normalize_ratio(state.chokepoints_owned_ratio)
    local hyperlane_depth = normalize_ratio(state.hyperlane_depth)
    local border_friction = normalize_ratio(state.border_friction)
    local gateways = normalize_ratio(state.gateway_access)
    local critical_chokepoints = math.max(1, safe_number(state.critical_chokepoints, 1))
    local hinterland_ratio = normalize_ratio(state.empire_behind_two_chokepoints_ratio)
    local depth_collapse_penalty = 0
    if hinterland_ratio > 0.60 then
        depth_collapse_penalty = math.min(0.8, (hinterland_ratio - 0.60) * 2.0 + logistic_like(critical_chokepoints, 3.0) * 0.3)
    end

    local score =
        chokepoints * 0.40 +
        hyperlane_depth * 0.30 +
        gateways * 0.20 -
        border_friction * 0.25 -
        depth_collapse_penalty

    return clamp(score, -3.0, 3.0)
end

function StratAI:score_risk(state)
    local upcoming_wars = normalize_ratio(state.upcoming_wars_risk)
    local hostile_neighbors = normalize_ratio(state.hostile_neighbors_ratio)
    local crisis_proximity = normalize_ratio(state.crisis_proximity)
    local dangerous_events = normalize_ratio(state.unresolved_dangerous_events)
    local volatility = normalize_ratio(state.resource_volatility)

    local score =
        upcoming_wars * 0.25 +
        hostile_neighbors * 0.20 +
        crisis_proximity * 0.25 +
        dangerous_events * 0.15 +
        volatility * 0.15

    return clamp(score, 0.0, 3.0)
end

function StratAI:_crisis_phase_rank(v)
    return CRISIS_PHASE_ORDER[v or "none"] or 0
end

function StratAI:matches_meta_conditions(entry, state)
    local cond = entry.signature_conditions or {}
    if entry.phase and entry.phase ~= "any" and state.phase ~= entry.phase then return false end

    if cond.game_year_max and safe_number(state.game_year, safe_number(state.year, 2300)) > cond.game_year_max then return false end
    if cond.game_year_min and safe_number(state.game_year, safe_number(state.year, 2300)) < cond.game_year_min then return false end

    local alloys_pp = safe_number(state.net_alloys, 0) / math.max(1, safe_number(state.pops, 1))
    if cond.net_alloys_pp_min and alloys_pp < cond.net_alloys_pp_min then return false end

    local tech_rel = safe_number(state.tech_tier, 1) / math.max(1, safe_number(state.enemy_tech_tier, 1))
    if cond.tech_tier_rel_max and tech_rel > cond.tech_tier_rel_max then return false end

    if cond.hostile_neighbors_ratio_max and normalize_ratio(state.hostile_neighbors_ratio) > cond.hostile_neighbors_ratio_max then return false end
    if cond.planet_count_max and safe_number(state.planet_count, 0) > cond.planet_count_max then return false end
    if cond.influence_income_min and safe_number(state.influence_income, 0) < cond.influence_income_min then return false end
    if cond.chokepoints_owned_ratio_min and normalize_ratio(state.chokepoints_owned_ratio) < cond.chokepoints_owned_ratio_min then return false end

    if cond.naval_cap_usage_ratio_max and normalize_ratio(state.naval_cap_usage_ratio) > cond.naval_cap_usage_ratio_max then return false end
    if cond.naval_cap_used_ratio_min and normalize_ratio(state.naval_cap_usage_ratio) < cond.naval_cap_used_ratio_min then return false end
    if cond.repeatables_unlocked ~= nil and (state.repeatables_unlocked == true) ~= cond.repeatables_unlocked then return false end

    local st_phase = state.crisis_phase or "none"
    if cond.crisis_phase and st_phase ~= cond.crisis_phase then return false end
    if cond.crisis_phase_min and self:_crisis_phase_rank(st_phase) < self:_crisis_phase_rank(cond.crisis_phase_min) then return false end
    if cond.crisis_proximity_min and normalize_ratio(state.crisis_proximity) < cond.crisis_proximity_min then return false end

    local our_ratio = safe_number(state.our_power, 0) / math.max(1, safe_number(state.crisis_fleet_power, 1))
    if cond.our_fleet_crisis_ratio_min and our_ratio < cond.our_fleet_crisis_ratio_min then return false end
    if cond.our_fleet_crisis_ratio_max and our_ratio > cond.our_fleet_crisis_ratio_max then return false end

    if cond.enemy_crisis_fleet_ratio_max and normalize_ratio(state.enemy_crisis_fleet_ratio) > cond.enemy_crisis_fleet_ratio_max then return false end
    if cond.crisis_strength_max and normalize_ratio(state.crisis_strength) > cond.crisis_strength_max then return false end
    if cond.crisis_type and state.crisis_type ~= cond.crisis_type then return false end
    if cond.crisis_killer and state.crisis_killer ~= cond.crisis_killer then return false end

    if cond.arc_emitter_tech_unlocked ~= nil and (state.arc_emitter_tech_unlocked == true) ~= cond.arc_emitter_tech_unlocked then return false end
    if cond.pd_tech_unlocked ~= nil and (state.pd_tech_unlocked == true) ~= cond.pd_tech_unlocked then return false end
    if cond.tracking_tech_unlocked ~= nil and (state.tracking_tech_unlocked == true) ~= cond.tracking_tech_unlocked then return false end
    if cond.strike_craft_tech_unlocked ~= nil and (state.strike_craft_tech_unlocked == true) ~= cond.strike_craft_tech_unlocked then return false end

    if cond.net_alloys_min and safe_number(state.net_alloys, 0) < cond.net_alloys_min then return false end
    if cond.enemy_power_rel_max and safe_number(state.enemy_power_rel, 1) > cond.enemy_power_rel_max then return false end
    if cond.border_seal_opportunity_min and normalize_ratio(state.border_seal_opportunity) < cond.border_seal_opportunity_min then return false end
    if cond.unity_per_month_min and safe_number(state.unity_per_month, 0) < cond.unity_per_month_min then return false end

    if cond.bio_ascension ~= nil and ((state.bio_ascension == true) ~= cond.bio_ascension) then return false end
    if cond.machine_age_virtuality ~= nil and ((state.machine_age_virtuality == true) ~= cond.machine_age_virtuality) then return false end
    if cond.shattered_ring_origin ~= nil and ((state.shattered_ring_origin == true) ~= cond.shattered_ring_origin) then return false end
    if cond.pop_growth_pressure_min and normalize_ratio(state.pop_growth_pressure) < cond.pop_growth_pressure_min then return false end
    if cond.planet_capacity_pressure_min and normalize_ratio(state.planet_capacity_pressure) < cond.planet_capacity_pressure_min then return false end
    if cond.net_energy_pp_min then
        local en_pp = safe_number(state.net_energy, 0) / math.max(1, safe_number(state.pops, 1))
        if en_pp < cond.net_energy_pp_min then return false end
    end
    if cond.alloy_density_min and normalize_ratio(state.alloy_density) < cond.alloy_density_min then return false end

    return true
end

function StratAI:select_meta_strategy(state)
    local matches = {}
    local dynamic_templates = self:build_dynamic_meta_templates(state)
    for _, entry in ipairs(dynamic_templates) do
        if self:matches_meta_conditions(entry, state) then
            matches[#matches + 1] = entry
        end
    end
    for _, entry in ipairs(META_TABLE) do
        if self:matches_meta_conditions(entry, state) then
            matches[#matches + 1] = entry
        end
    end
    if #matches == 0 then
        self.strongest_meta = nil
        self.meta_hysteresis.lock = math.max(0, safe_number((self.meta_hysteresis or {}).lock, 0) - 1)
        return nil
    end

    table.sort(matches, function(a, b)
        local ac = safe_number(a.confidence, 0.5)
        local bc = safe_number(b.confidence, 0.5)
        local a_cr = ((a.signature_conditions or {}).crisis_phase or (a.signature_conditions or {}).crisis_phase_min) and 1 or 0
        local b_cr = ((b.signature_conditions or {}).crisis_phase or (b.signature_conditions or {}).crisis_phase_min) and 1 or 0
        if a_cr ~= b_cr then return a_cr > b_cr end
        return ac > bc
    end)

    local best = matches[1]
    self.meta_hysteresis = self.meta_hysteresis or { strategy = nil, lock = 0 }
    if self.meta_hysteresis.strategy and self.meta_hysteresis.lock > 0 then
        local current = self.meta_hysteresis.strategy
        local current_conf = safe_number(current.confidence, 0.5)
        local best_conf = safe_number(best.confidence, 0.5)
        if current.strategy_name ~= best.strategy_name and (best_conf - current_conf) < 0.06 then
            best = current
        end
        self.meta_hysteresis.lock = self.meta_hysteresis.lock - 1
    end

    if not self.meta_hysteresis.strategy or self.meta_hysteresis.strategy.strategy_name ~= best.strategy_name then
        self.meta_hysteresis.strategy = best
        self.meta_hysteresis.lock = 6
    end

    self.strongest_meta = best
    return best
end

function StratAI:meta_action_bias(action, state)
    local meta = self.strongest_meta
    if not meta then return 1.0 end
    local mods = meta.weight_modifiers or {}
    local mul = 1.0
    if action.type == "declare_war" or action.type == "containment_front" then mul = mul * safe_number(mods.Mil, 1.0) end
    if action.type == "build" or action.type == "delay_stockpile" then mul = mul * safe_number(mods.Eco, 1.0) end
    if action.type == "research" or action.type == "tech_denial" then mul = mul * safe_number(mods.Tech, 1.0) end
    if action.type == "seal_borders" or action.type == "fortify_chokepoint" then mul = mul * safe_number(mods.Pos, 1.0) end

    local prox = normalize_ratio(state.crisis_proximity)
    if state.crisis_phase and state.crisis_phase ~= "none" then
        mul = mul * (1 + 0.35 * prox)
    else
        mul = mul * (1 + 0.15 * prox)
    end

    return clamp(mul, 0.6, 2.4)
end

function StratAI:matches_counter_meta_conditions(entry, state, rival_model)
    local cond = entry.opponent_signature_conditions or {}
    local rm = rival_model or {}

    if cond.game_year_max and safe_number(state.game_year, 0) > cond.game_year_max then return false end
    if cond.game_year_min and safe_number(state.game_year, 0) < cond.game_year_min then return false end

    local enemy_research_pp = safe_number(state.enemy_total_research, 0) / math.max(1, safe_number(state.enemy_pops, 1))
    local enemy_alloys_pp = safe_number(state.enemy_alloy_per_pop, 0)
    local tech_rel = safe_number(state.tech_tier, 1) / math.max(1, safe_number(state.enemy_tech_tier, 1))
    local our_tech_rel = tech_rel

    if cond.enemy_research_pp_min and enemy_research_pp < cond.enemy_research_pp_min then return false end
    if cond.enemy_alloy_per_pop_min and enemy_alloys_pp < cond.enemy_alloy_per_pop_min then return false end
    if cond.tech_tier_rel_min and tech_rel < cond.tech_tier_rel_min then return false end
    if cond.our_tech_tier_rel_max and our_tech_rel > cond.our_tech_tier_rel_max then return false end

    if cond.enemy_planet_count_min and safe_number(state.enemy_planet_count, 0) < cond.enemy_planet_count_min then return false end
    if cond.enemy_planet_count_max and safe_number(state.enemy_planet_count, 0) > cond.enemy_planet_count_max then return false end
    if cond.enemy_habitat_count_min and safe_number(state.enemy_habitat_count, 0) < cond.enemy_habitat_count_min then return false end
    if cond.enemy_starbase_count_min and safe_number(state.enemy_starbase_count, 0) < cond.enemy_starbase_count_min then return false end
    if cond.enemy_chokepoints_owned_ratio_min and normalize_ratio(state.enemy_chokepoints_owned_ratio) < cond.enemy_chokepoints_owned_ratio_min then return false end

    if cond.enemy_mega_shipyard_count_min and safe_number(state.enemy_mega_shipyard_count, 0) < cond.enemy_mega_shipyard_count_min then return false end
    if cond.enemy_fleet_power_growth_min and safe_number(state.enemy_fleet_power_growth, 0) < cond.enemy_fleet_power_growth_min then return false end

    if cond.enemy_ship_class_corvette_min and safe_number(rm.ship_class_corvette, 0) < cond.enemy_ship_class_corvette_min then return false end
    if cond.enemy_ship_class_battleship_min and safe_number(rm.ship_class_battleship, 0) < cond.enemy_ship_class_battleship_min then return false end
    if cond.enemy_missile_usage_min and safe_number(rm.missile_usage, 0) < cond.enemy_missile_usage_min then return false end
    if cond.enemy_range_bias_min and safe_number(rm.range_bias, 0) < cond.enemy_range_bias_min then return false end
    if cond.enemy_evasion_bias_min and safe_number(rm.evasion_bias, 0) < cond.enemy_evasion_bias_min then return false end
    if cond.enemy_pd_strength_min and safe_number(state.enemy_pd_strength, safe_number(rm.pd_weight, 0)) < cond.enemy_pd_strength_min then return false end

    if cond.enemy_tracking_weak ~= nil and ((safe_number(rm.tracking_weight, 0) < 0.4) ~= cond.enemy_tracking_weak) then return false end
    if cond.enemy_has_battleships ~= nil and ((state.enemy_has_battleships == true) ~= cond.enemy_has_battleships) then return false end

    if cond.crisis_proximity_min and normalize_ratio(state.crisis_proximity) < cond.crisis_proximity_min then return false end
    if cond.enemy_strategic_coordination_center ~= nil and ((state.enemy_strategic_coordination_center == true) ~= cond.enemy_strategic_coordination_center) then return false end
    if cond.enemy_chokepoint_coverage_min and normalize_ratio(state.enemy_chokepoint_coverage) < cond.enemy_chokepoint_coverage_min then return false end
    if cond.enemy_fortress_worlds_min and safe_number(state.enemy_fortress_worlds, 0) < cond.enemy_fortress_worlds_min then return false end

    if cond.enemy_megastructures_online_min and safe_number(state.enemy_megastructures_online, 0) < cond.enemy_megastructures_online_min then return false end
    if cond.enemy_megastructures_in_progress_min and safe_number(state.enemy_megastructures_in_progress, 0) < cond.enemy_megastructures_in_progress_min then return false end
    if cond.our_megastructures_online_max and safe_number(state.our_megastructures_online, 0) > cond.our_megastructures_online_max then return false end

    if cond.enemy_bio_ascension ~= nil and ((state.enemy_bio_ascension == true) ~= cond.enemy_bio_ascension) then return false end
    if cond.enemy_machine_age_virtuality ~= nil and ((state.enemy_machine_age_virtuality == true) ~= cond.enemy_machine_age_virtuality) then return false end
    if cond.enemy_shattered_ring_origin ~= nil and ((state.enemy_shattered_ring_origin == true) ~= cond.enemy_shattered_ring_origin) then return false end
    if cond.enemy_pop_growth_pressure_min and normalize_ratio(state.enemy_pop_growth_pressure) < cond.enemy_pop_growth_pressure_min then return false end

    return true
end

function StratAI:record_decision_why(action, why, state)
    self.decision_memory[#self.decision_memory + 1] = {
        action = action and action.type or "none",
        why = why or "",
        time = safe_number(state and state.game_year, 0),
        snapshot = {
            reinforcement_time = safe_number(state and state.reinforcement_time, 0),
            counter_score = safe_number(state and state.counter_score, 0),
            net_cg = safe_number(state and state.net_consumer_goods, 0)
        }
    }
    if #self.decision_memory > 64 then table.remove(self.decision_memory, 1) end
end

function StratAI:update_domain_confidence(state)
    local err = math.abs(safe_number(state.predicted_eval_delta, 0) - safe_number(state.observed_eval_delta, 0))
    local step = (err > 0.35) and -0.02 or 0.01
    for k, v in pairs(self.domain_confidence) do
        self.domain_confidence[k] = clamp(v + step, 0.55, 1.20)
    end
    return self.domain_confidence
end

function StratAI:confidence_adjusted_aggression(state)
    local c = self.domain_confidence
    local military_c = safe_number(c.military, 1.0)
    local diplomacy_c = safe_number(c.diplomacy, 1.0)
    return clamp((military_c + diplomacy_c) * 0.5, 0.55, 1.15)
end

function StratAI:detect_bottleneck(state)
    local bottlenecks = {
        alloys = (safe_number(state.net_alloys, 0) < 5) and (10 - safe_number(state.net_alloys, 0)) or 0,
        pops = (safe_number(state.our_pop_growth, 0) < safe_number(state.enemy_pop_growth, 0)) and (safe_number(state.enemy_pop_growth,0)-safe_number(state.our_pop_growth,0)) * 5 or 0,
        naval_cap = math.max(0, normalize_ratio(state.naval_cap_usage_ratio) - 0.95) * 10,
        tech_tier = math.max(0, safe_number(state.enemy_tech_tier, 1) - safe_number(state.tech_tier, 1)) * 4,
        influence = (safe_number(state.influence_income, 1) < 1) and (1 - safe_number(state.influence_income,1)) * 6 or 0
    }
    local best, val = "alloys", -1
    for k, v in pairs(bottlenecks) do
        if v > val then best, val = k, v end
    end
    return best, val, bottlenecks
end

function StratAI:window_model(state)
    local windows = {
        military_window = clamp(logistic_like(safe_number(state.military_advantage,0), 0.8), -1, 1),
        tech_window = clamp(logistic_like(safe_number(state.tech_tier,1)-safe_number(state.enemy_tech_tier,1), 0.5), -1, 1),
        economic_safety_window = clamp(logistic_like(safe_number(state.net_energy,0)+safe_number(state.net_alloys,0), 25), -1, 1)
    }
    return windows
end

function StratAI:hard_no_guardrails(state, action)
    local break_window = state.rule_break_window == true
    local shortest = safe_number((state.failure_clocks or {}).shortest, 999)
    local extinction_risk = shortest <= 8

    if self.strongest_meta and self.strongest_meta.hard_guardrails then
        local guards = self.strongest_meta.hard_guardrails
        local emergency = normalize_ratio(state.crisis_proximity) > 0.9 and (safe_number(state.our_power, 0) / math.max(1, safe_number(state.crisis_fleet_power, 1))) < 0.5
        if not emergency then
            if guards.no_declare_war and action.type == "declare_war" then return false, "Meta guardrail: no war" end
            if guards.no_colonize and action.type == "colonize" then return false, "Meta guardrail: no colonize" end
            if guards.no_offensive_war and (action.type == "declare_war" or action.type == "containment_front") then return false, "Meta guardrail: no offensive war" end
        end
    end

    if action.type == "declare_war" and normalize_ratio(state.two_front_war_risk) > 0.5 and not extinction_risk then
        return false, "Hard NO: avoid two-front war"
    end

    local cg_limit = safe_number((self.config.strategic or {}).cg_deficit_limit, -8)
    local cg_months = safe_number(state.cg_deficit_months, 0)
    local cg_max_m = safe_number((self.config.strategic or {}).cg_deficit_max_months, 12)
    if safe_number(state.net_consumer_goods, 0) <= cg_limit and cg_months > cg_max_m and not break_window then
        return false, "Hard NO: prolonged severe CG deficit"
    end

    local pivot_th = safe_number((self.config.strategic or {}).doctrine_pivot_threshold, -0.35)
    if action.type == "redesign_fleet" and state.at_war and safe_number(state.counter_score, 0) >= pivot_th and not break_window then
        return false, "Hard NO: no mid-war doctrine pivot"
    end

    return true, "Hard guardrails passed"
end

function StratAI:estimate_failure_clocks(state)
    local clocks = {}

    local econ_deficit = math.max(0, -safe_number(state.net_energy, 0)) + math.max(0, -safe_number(state.net_consumer_goods, 0))
    clocks.economy = (econ_deficit > 0) and (24 / (1 + econ_deficit)) or 999

    local mil_gap = math.max(0, safe_number(state.enemy_power, 0) - safe_number(state.our_power, 0))
    local reinforce_adv = math.max(0.1, safe_number(state.our_reinforcement_speed, 1)) / math.max(0.1, safe_number(state.enemy_reinforcement_speed, 1))
    clocks.military = (mil_gap > 0) and (30 / (1 + mil_gap * 0.01) * reinforce_adv) or 999

    local tech_gap = math.max(0, safe_number(state.enemy_tech_tier, 1) - safe_number(state.tech_tier, 1))
    local our_research = math.max(0.1, safe_number(state.total_research, 1))
    local enemy_research = math.max(0.1, safe_number(state.enemy_total_research, our_research))
    local tech_velocity_ratio = our_research / enemy_research
    clocks.tech = (tech_gap > 0) and (36 / (1 + tech_gap) * tech_velocity_ratio) or 999

    local pop_gap_growth = math.max(0, safe_number(state.enemy_pop_growth, 0) - safe_number(state.our_pop_growth, 0))
    clocks.population = (pop_gap_growth > 0) and (40 / (1 + pop_gap_growth)) or 999

    clocks.shortest = math.min(clocks.economy, clocks.military, clocks.tech, clocks.population)
    self.failure_clocks = clocks
    return clocks
end

function StratAI:effective_game_over(state)
    local production_locked = normalize_ratio(state.enemy_production_contestable) < 0.2
    local borders_sealed = normalize_ratio(state.border_seal_opportunity) > 0.75
    local tech_locked = (safe_number(state.tech_tier, 1) / math.max(1, safe_number(state.enemy_tech_tier, 1))) >= 1.1
    local allies_irrelevant = normalize_ratio(state.enemy_allied_support) < 0.25

    local confidence = 0
    confidence = confidence + (production_locked and 0.30 or 0)
    confidence = confidence + (borders_sealed and 0.25 or 0)
    confidence = confidence + (tech_locked and 0.25 or 0)
    confidence = confidence + (allies_irrelevant and 0.20 or 0)

    local threshold = safe_number((self.config.strategic or {}).closure_confidence, 0.75)
    return confidence >= threshold, confidence
end

function StratAI:update_enemy_mind_model(enemy_id, signal)
    local m = self.enemy_mind_models[enemy_id] or { risk_tolerance = 0.5, overreact = 0.5, turtle = 0.5, bad_war_accept = 0.5 }
    local i = self.config.inertia
    m.risk_tolerance = blend(m.risk_tolerance, normalize_ratio(signal.risk_tolerance), i)
    m.overreact = blend(m.overreact, normalize_ratio(signal.overreact), i)
    m.turtle = blend(m.turtle, normalize_ratio(signal.turtle), i)
    m.bad_war_accept = blend(m.bad_war_accept, normalize_ratio(signal.bad_war_accept), i)
    self.enemy_mind_models[enemy_id] = m
    return m
end

function StratAI:pressure_psychology_score(state)
    if not state.primary_rival then return 0 end
    local m = self.enemy_mind_models[state.primary_rival] or { risk_tolerance = 0.5, overreact = 0.5, turtle = 0.5, bad_war_accept = 0.5 }
    local border_pressure = normalize_ratio(state.border_pressure_window)
    local bait_window = normalize_ratio(state.fake_weakness_window)
    local defense_trap = normalize_ratio(state.prepared_defense_window)
    local s = border_pressure * m.overreact * 0.35 + bait_window * m.bad_war_accept * 0.35 + defense_trap * (1 - m.turtle) * 0.30
    return clamp(s, 0, 1.2)
end

function StratAI:volatility_opportunity(state)
    local vol = normalize_ratio(state.galactic_volatility)
    local crisis_near_rival = normalize_ratio(state.crisis_near_rival)
    local desperation = (self.failure_clocks.shortest and self.failure_clocks.shortest < 24) and 1 or 0
    local conservative = (desperation == 0) and (1 - normalize_ratio(state.intel_uncertainty)) or 1
    local lever = safe_number((self.config.strategic or {}).volatility_leverage, 0.12)
    return clamp((vol * crisis_near_rival * conservative + desperation * vol) * lever, -0.5, 0.8)
end

function StratAI:update_empire_identity(state)
    local eco = safe_number(state.net_energy, 0) + safe_number(state.net_alloys, 0)
    local mil = safe_number(state.military_advantage, 0)
    local tech = safe_number(state.tech_tier, 1) - safe_number(state.enemy_tech_tier, 1)

    if civics_has(state, "honorbound_warriors") or ethics_has(state, "militarist") then
        self.empire_identity = "honorbound_martial"
    elseif civics_has(state, "hive_mind") or ethics_has(state, "gestalt_consciousness") then
        self.empire_identity = "hive_adaptive"
    elseif eco > 25 and mil > 0 and tech >= 0 then
        self.empire_identity = "economic_hegemon"
    elseif mil < -0.2 and tech < 0 then
        self.empire_identity = "militarized_underdog"
    elseif tech > 0.3 then
        self.empire_identity = "tech_snowball"
    else
        self.empire_identity = "balanced_power"
    end
    return self.empire_identity
end

function StratAI:identity_consistency_penalty(action)
    if not action then return 0 end
    local id = self.empire_identity or "balanced_power"
    if id == "economic_hegemon" and action.type == "declare_war" then return 0.10 end
    if id == "militarized_underdog" and action.type == "build" and action.target == "research_lab" then return 0.08 end
    if id == "tech_snowball" and action.type == "seal_borders" then return 0.05 end
    if id == "honorbound_martial" and action.type == "delay_stockpile" then return 0.07 end
    if id == "hive_adaptive" and action.type == "build" and action.target == "generator_district" then return -0.03 end
    return 0
end

function StratAI:rule_break_window(state)
    local clocks = self.failure_clocks
    local shortest = safe_number(clocks.shortest, 999)
    local last_timing = normalize_ratio(state.last_viable_timing_window)
    local overextension = normalize_ratio(state.enemy_overextension_window)
    local chaos = (self.galaxy_meta.crisis_phase ~= "none") and 1 or 0

    local trigger = shortest <= safe_number((self.config.strategic or {}).break_rule_window_years, 8) or last_timing > 0.7 or overextension > 0.7 or chaos == 1
    return trigger
end

function StratAI:apply_ml_advisory_to_weights(weights)
    local cfg = self.config.ml_advisory or {}
    if cfg.enabled == false then return weights end

    local out = deep_copy(weights)
    local deltas = (self.ml_advisory or {}).weight_delta or {}
    local max_d = safe_number(cfg.max_weight_delta, 0.05)

    for _, k in ipairs({"Eco","Mil","Tech","Stab","Pos","Risk"}) do
        local d = clamp(safe_number(deltas[k], 0), -max_d, max_d)
        out[k] = math.max(0, safe_number(out[k], 0) + d)
    end

    return out
end

function StratAI:update_ml_advisory(predicted_delta, observed_delta)
    local cfg = self.config.ml_advisory or {}
    if cfg.enabled == false then return end

    local err = safe_number(observed_delta, 0) - safe_number(predicted_delta, 0)
    local max_w = safe_number(cfg.max_weight_delta, 0.05)
    local step = clamp(err * 0.01, -0.01, 0.01)

    self.ml_advisory.weight_delta.Eco = clamp(safe_number(self.ml_advisory.weight_delta.Eco,0) + step, -max_w, max_w)
    self.ml_advisory.weight_delta.Mil = clamp(safe_number(self.ml_advisory.weight_delta.Mil,0) - step*0.5, -max_w, max_w)
    self.ml_advisory.weight_delta.Tech = clamp(safe_number(self.ml_advisory.weight_delta.Tech,0) + step*0.4, -max_w, max_w)

    local max_r = safe_number(cfg.max_risk_delta, 0.03)
    self.ml_advisory.risk_delta = clamp(safe_number(self.ml_advisory.risk_delta,0) - err*0.005, -max_r, max_r)

    if cfg.remote_enabled and cfg.remote_endpoint then
        self.ml_advisory_remote_status.last_sync_year = safe_number((self.last_eval or {}).year, self.ml_advisory_remote_status.last_sync_year)
        self.ml_advisory_remote_status.status = "queued_remote_sync"
    end
end

function StratAI:get_phase_weights(phase)
    return PHASE_WEIGHTS[phase] or PHASE_WEIGHTS[PHASE.MID]
end

function StratAI:_apply_difficulty_profile(weights)
    local p = self.config.difficulty_profile or {}
    local w = deep_copy(weights)
    w.Eco = safe_number(w.Eco, 0) * safe_number(p.eco_bias, 1.0)
    w.Tech = safe_number(w.Tech, 0) * safe_number(p.tech_bias, 1.0)
    w.Mil = safe_number(w.Mil, 0) * safe_number(p.mil_bias, 1.0)
    return w
end

function StratAI:evaluate_state(state, phase)
    local w = deep_copy(self:get_phase_weights(phase))
    w = self:_apply_difficulty_profile(w)
    w = self:apply_ml_advisory_to_weights(w)

    if self.galaxy_meta.crisis_phase ~= "none" then
        w.Mil = w.Mil + 0.10
        w.Eco = w.Eco + 0.05
        w.Pos = math.max(0.02, w.Pos - 0.05)
    end

    local Eco = self:score_economy(state)
    local Mil = self:score_military(state)
    local Tech = self:score_tech(state)
    local Stab = self:score_stability(state)
    local Pos = self:score_position(state)
    local Risk = self:score_risk(state)

    local trend_term = self:trajectory_advantage()
    local irreversibility = self:irreversibility_index(state, phase)
    local clausewitz_irreversibility, mtf_detail = self:global_irreversibility_trigger(state)
    local closure = self:closure_mode_score(state)
    local psycho = self:pressure_psychology_score(state)
    local volatility = self:volatility_opportunity(state)

    local E =
        (w.Eco * Eco) +
        (w.Mil * Mil) +
        (w.Tech * Tech) +
        (w.Stab * Stab) +
        (w.Pos * Pos) -
        (math.max(0, w.Risk + safe_number((self.ml_advisory or {}).risk_delta, 0)) * Risk) +
        trend_term +
        closure +
        psycho +
        volatility -
        irreversibility -
        clausewitz_irreversibility

    E = clamp(E, -self.config.score_clip, self.config.score_clip)

    self.last_eval = {
        phase = phase,
        total = E,
        components = {
            Eco = Eco, Mil = Mil, Tech = Tech, Stab = Stab, Pos = Pos, Risk = Risk,
            Trend = trend_term, Irreversibility = irreversibility, ClausewitzIrreversibility = clausewitz_irreversibility,
            TimeToFailure = mtf_detail, Closure = closure,
            PressurePsychology = psycho, Volatility = volatility
        },
        weights = deep_copy(w)
    }

    self:_append_eval_history(E)
    return E, self.last_eval
end

-- ############################################################
-- 4) WAR & META PRESSURE LOGIC
-- ############################################################

function StratAI:point_of_no_return(state)
    local enemy_alloy_pp = safe_number(state.enemy_alloy_per_pop, 0)
    local our_alloy_pp = math.max(0.01, safe_number(state.our_alloy_per_pop, 0.01))
    local alloy_ratio = enemy_alloy_pp / our_alloy_pp

    local no_expansion = state.expansion_paths_left == 0
    local megastructure_pressure = state.enemy_has_megastructures and (safe_number(state.tech_tier,1) + 0.5 < safe_number(state.enemy_tech_tier,1))

    local triggered = (alloy_ratio > 1.45 and no_expansion) or (megastructure_pressure and alloy_ratio > 1.20)
    if triggered then
        return true, {
            risk_tolerance_boost = 0.20,
            war_threshold_delta = -0.08,
            allow_gambles = true
        }
    end

    return false, { risk_tolerance_boost = 0, war_threshold_delta = 0, allow_gambles = false }
end

function StratAI:war_commit_score(state)
    local mil_advantage = logistic_like(safe_number(state.military_advantage, 0), 1.0)
    local counter_score = clamp(safe_number(state.counter_score, 0), -1.0, 1.0)
    local positional_adv = logistic_like(safe_number(state.positional_advantage, 0), 1.0)
    local risk_threshold = safe_number(state.risk_threshold, 0.25)

    local ponr, ponr_adj = self:point_of_no_return(state)
    risk_threshold = risk_threshold + safe_number(ponr_adj.war_threshold_delta, 0)

    local score = mil_advantage * counter_score * positional_adv
    local can_win_24m = state.projected_war_win_months and state.projected_war_win_months <= self.config.war_horizon_months

    if not can_win_24m then
        score = score - 0.30
    end

    local projected_losses = normalize_ratio(state.projected_war_losses_alloy_ratio)
    local no_surplus = safe_number(state.net_alloys, 0) <= 0 or safe_number(state.net_energy, 0) <= 0
    if projected_losses > self.config.war_loss_tolerance and no_surplus and not ponr then
        return -1.0, risk_threshold, "War veto: loss tolerance exceeded without surplus"
    end

    return score, risk_threshold, "War score computed"
end

function StratAI:should_start_war(state)
    local score, threshold, reason = self:war_commit_score(state)

    if safe_number(state.our_active_fronts, 1) >= 2 and normalize_ratio(state.enemy_active_fronts) < 0.4 then
        return false, "War veto: avoid opening a two-front war"
    end
    if safe_number(state.net_consumer_goods, 0) < -4 or safe_number(state.net_energy, 0) < -10 then
        return false, "War veto: economy spiral risk"
    end

    local aggression = clamp(safe_number(self.config.aggression_slider, 1.0), 0.5, 2.0)
    local tuned_threshold = threshold / aggression
    if score > tuned_threshold then
        return true, "War conditions satisfied"
    end
    return false, reason or "War score below threshold"
end

function StratAI:crisis_counter_action_bonus(state, action)
    if not action then return 0 end
    if state.crisis_phase == "none" then return 0 end

    local c = state.crisis_type or "other"
    local bonus = 0

    if c == "unbidden" and (action.type == "research" or action.type == "redesign_fleet") then
        bonus = bonus + 0.12
    elseif c == "contingency" and (action.type == "redesign_fleet" or action.type == "fortify_chokepoint") then
        bonus = bonus + 0.10
    elseif c == "scourge" and (action.type == "redesign_fleet" or action.type == "rotate_fleets") then
        bonus = bonus + 0.08
    end

    return bonus
end

function StratAI:meta_pressure_adjustments(state)
    local g = self.galaxy_meta
    local flags = state.tech_flags or {}
    local adjustments = {
        tech_urgency = 0,
        military_urgency = 0,
        economy_urgency = 0
    }

    if g.dominant_ship_class == "cruiser" and not flags.battleships then
        adjustments.tech_urgency = adjustments.tech_urgency + 0.30
    end

    if g.avg_tech_tier >= 4 and not flags.repeatables then
        adjustments.tech_urgency = adjustments.tech_urgency + 0.35
    end

    if g.crisis_phase ~= "none" then
        adjustments.military_urgency = adjustments.military_urgency + 0.40
    end

    if safe_number(state.enemy_alloy_per_pop, 0) > safe_number(state.our_alloy_per_pop, 0) then
        adjustments.economy_urgency = adjustments.economy_urgency + 0.20
        adjustments.military_urgency = adjustments.military_urgency + 0.20
    end

    if state.enemy_has_megastructures then
        adjustments.economy_urgency = adjustments.economy_urgency + 0.20
    end

    if state.enemy_has_ecumenopolis then
        adjustments.military_urgency = adjustments.military_urgency + 0.15
    end

    if safe_number(state.hostile_neighbors_ratio, 0) <= 0.05
       and safe_number(state.military_advantage, 0) > 0
       and safe_number(state.net_energy, 0) > 0
       and safe_number(state.net_alloys, 0) > 0 then
        adjustments.tech_urgency = adjustments.tech_urgency * 0.85
    end

    return adjustments
end

-- ############################################################
-- 5) ACTION GENERATION + SHALLOW SIMULATION
-- ############################################################

function StratAI:generate_actions(state)
    local actions = {}

    actions[#actions + 1] = { type = "delay_stockpile" }

    if state.can_build then
        actions[#actions + 1] = { type = "build", target = "alloy_foundry" }
        actions[#actions + 1] = { type = "build", target = "research_lab" }
        actions[#actions + 1] = { type = "build", target = "generator_district" }
    end

    if state.can_research then
        actions[#actions + 1] = { type = "research", target = "military_tech" }
        actions[#actions + 1] = { type = "research", target = "economy_tech" }
        actions[#actions + 1] = { type = "research", target = "repeatable_focus" }
    end

    if state.can_redesign_fleet then
        actions[#actions + 1] = { type = "redesign_fleet", target = "adaptive_counter" }
    end

    if state.can_colonize and state.best_colony_candidate then
        actions[#actions + 1] = { type = "colonize", target = state.best_colony_candidate }
    end

    if state.can_declare_war then
        actions[#actions + 1] = { type = "declare_war", target = state.primary_rival }
    end

    if normalize_ratio(state.border_seal_opportunity) > 0.5 then
        actions[#actions + 1] = { type = "seal_borders" }
    end
    if normalize_ratio(state.vassalization_window) > 0.5 then
        actions[#actions + 1] = { type = "seek_vassalization" }
    end
    if normalize_ratio(state.tech_denial_window) > 0.5 then
        actions[#actions + 1] = { type = "tech_denial" }
    end
    if normalize_ratio(state.intentional_retreat_window) > 0.45 then actions[#actions + 1] = { type = "intentional_retreat" } end
    if normalize_ratio(state.sensor_shadow_window) > 0.45 then actions[#actions + 1] = { type = "deception_feint" } end
    if normalize_ratio(state.enemy_shipyard_exposure) > 0.45 or normalize_ratio(state.enemy_trade_exposure) > 0.45 then actions[#actions + 1] = { type = "economic_raid" } end
    if normalize_ratio(state.enemy_active_fronts) > 0.35 then actions[#actions + 1] = { type = "multi_front_raid" } end
    if normalize_ratio(state.anti_hegemon_sentiment) > 0.45 then actions[#actions + 1] = { type = "form_coalition" } end
    if normalize_ratio(state.federation_opportunity) > 0.45 then actions[#actions + 1] = { type = "form_federation" } end
    if normalize_ratio(state.top_empire_power_share) > 0.42 then actions[#actions + 1] = { type = "containment_front" } end
    if normalize_ratio(state.top_empire_power_share) > 0.48 then actions[#actions + 1] = { type = "embargo_hegemon" } end
    if safe_number(state.year, 2300) >= safe_number(state.crisis_prep_year, 2360) then actions[#actions + 1] = { type = "prepare_crisis" } end

    if (state.friend_mode == true) or ((self.config.friend_mode or {}).enabled == true) then
        actions[#actions + 1] = { type = "intercept_threat" }
        actions[#actions + 1] = { type = "escort_player_fleet" }
        actions[#actions + 1] = { type = "fire_brigade" }
        actions[#actions + 1] = { type = "evacuation_guard" }
        actions[#actions + 1] = { type = "stabilize_economy" }
    end

    if normalize_ratio(state.crisis_proximity) > 0.45 or normalize_ratio(state.crisis_path_to_player) > 0.45 then
        actions[#actions + 1] = { type = "fortify_chokepoint" }
        if not ((self.config.compatibility or {}).disable_hyper_relay_spam == true and normalize_ratio(state.hyper_relay_saturation) > 0.6) then
            actions[#actions + 1] = { type = "build_forward_shipyard" }
        end
        actions[#actions + 1] = { type = "rotate_fleets" }
        actions[#actions + 1] = { type = "target_crisis_nodes" }
        actions[#actions + 1] = { type = "emergency_conversion" }
        actions[#actions + 1] = { type = "hold_line_primary" }
        actions[#actions + 1] = { type = "hold_line_secondary" }
        actions[#actions + 1] = { type = "intentional_sacrifice" }
    end

    if state.effective_game_over then
        actions[#actions + 1] = { type = "vassalization_chain" }
        actions[#actions + 1] = { type = "chokehold_war" }
        actions[#actions + 1] = { type = "exhaustion_manipulation" }
        actions[#actions + 1] = { type = "attrition_abuse" }
    end

    if normalize_ratio(state.intel_uncertainty) > 0.5 and normalize_ratio(state.learning_cost) < 0.4 then
        actions[#actions + 1] = { type = "probe_skirmish" }
        actions[#actions + 1] = { type = "probe_diplomacy" }
        actions[#actions + 1] = { type = "test_counter" }
    end

    return actions
end

function StratAI:simulate_shallow(state, action, years)
    local horizon = clamp(safe_number(years, self.config.action_horizon_years), 1, 5)
    local s = deep_copy(state)

    if action.type == "build" and action.target == "alloy_foundry" then
        s.net_alloys = safe_number(s.net_alloys, 0) + 8 * horizon
        s.net_minerals = safe_number(s.net_minerals, 0) - 4 * horizon
        s.net_energy = safe_number(s.net_energy, 0) - 2 * horizon
    elseif action.type == "build" and action.target == "research_lab" then
        s.total_research = safe_number(s.total_research, 0) + 18 * horizon
        s.net_consumer_goods = safe_number(s.net_consumer_goods, 0) - 4 * horizon
        s.tech_tier = safe_number(s.tech_tier, 1) + 0.05 * horizon
    elseif action.type == "build" and action.target == "generator_district" then
        s.net_energy = safe_number(s.net_energy, 0) + 10 * horizon
        s.unused_district_capacity = math.max(0, safe_number(s.unused_district_capacity, 0) - 1)
    elseif action.type == "research" and action.target == "military_tech" then
        s.ship_tech_tier = safe_number(s.ship_tech_tier, 1) + 0.10 * horizon
        s.tech_tier = safe_number(s.tech_tier, 1) + 0.08 * horizon
    elseif action.type == "research" and action.target == "economy_tech" then
        s.pop_efficiency = safe_number(s.pop_efficiency, 0) + 0.08 * horizon
        s.tech_tier = safe_number(s.tech_tier, 1) + 0.06 * horizon
    elseif action.type == "research" and action.target == "repeatable_focus" then
        s.tech_tier = safe_number(s.tech_tier, 1) + 0.10 * horizon
        s.repeatables_unlocked = true
        s.total_research = safe_number(s.total_research, 0) + 10 * horizon
    elseif action.type == "redesign_fleet" then
        s.enemy_counter_risk = math.max(0, safe_number(s.enemy_counter_risk, 0) - 0.20)
        s.net_alloys = safe_number(s.net_alloys, 0) - 3 * horizon
    elseif action.type == "colonize" then
        s.planet_count = safe_number(s.planet_count, 1) + 1
        s.pops = safe_number(s.pops, 1) + 2 * horizon
        s.net_consumer_goods = safe_number(s.net_consumer_goods, 0) - 2 * horizon
        s.unused_district_capacity = safe_number(s.unused_district_capacity, 0) + 4
    elseif action.type == "declare_war" then
        s.upcoming_wars_risk = clamp(safe_number(s.upcoming_wars_risk, 0) + 0.40, 0, 1)
        s.net_alloys = safe_number(s.net_alloys, 0) - 6 * horizon
        s.military_advantage = safe_number(s.military_advantage, 0) + 0.15
        s.projected_war_win_months = safe_number(s.projected_war_win_months, 36) - 6 * horizon
    elseif action.type == "delay_stockpile" then
        s.net_alloys = safe_number(s.net_alloys, 0) + 4 * horizon
        s.net_energy = safe_number(s.net_energy, 0) + 3 * horizon
        s.resource_volatility = math.max(0, safe_number(s.resource_volatility, 0) - 0.05)
    elseif action.type == "seal_borders" then
        s.border_friction = math.max(0, safe_number(s.border_friction, 0) - 0.15)
        s.hostile_neighbors_ratio = math.max(0, safe_number(s.hostile_neighbors_ratio, 0) - 0.10)
    elseif action.type == "seek_vassalization" then
        s.military_advantage = safe_number(s.military_advantage, 0) + 0.08
        s.upcoming_wars_risk = math.max(0, safe_number(s.upcoming_wars_risk, 0) - 0.05)
    elseif action.type == "form_federation" then
        s.hostile_neighbors_ratio = math.max(0, safe_number(s.hostile_neighbors_ratio, 0) - 0.08)
        s.military_advantage = safe_number(s.military_advantage, 0) + 0.06
    elseif action.type == "tech_denial" then
        s.enemy_tech_tier = math.max(0.5, safe_number(s.enemy_tech_tier, 1) - 0.05 * horizon)
        s.tech_denial_window = math.max(0, safe_number(s.tech_denial_window, 0) - 0.2)
    elseif action.type == "probe_skirmish" then
        s.intel_uncertainty = math.max(0, safe_number(s.intel_uncertainty, 0) - 0.20)
        s.enemy_counter_risk = math.max(0, safe_number(s.enemy_counter_risk, 0) - 0.12)
        s.net_alloys = safe_number(s.net_alloys, 0) - 1 * horizon
    elseif action.type == "probe_diplomacy" then
        s.hostile_neighbors_ratio = math.max(0, safe_number(s.hostile_neighbors_ratio, 0) - 0.05)
        s.intel_uncertainty = math.max(0, safe_number(s.intel_uncertainty, 0) - 0.10)
    elseif action.type == "test_counter" then
        s.intel_uncertainty = math.max(0, safe_number(s.intel_uncertainty, 0) - 0.15)
        s.enemy_counter_risk = math.max(0, safe_number(s.enemy_counter_risk, 0) - 0.18)
        s.net_alloys = safe_number(s.net_alloys, 0) - 2 * horizon
    elseif action.type == "vassalization_chain" then
        s.enemy_production_contestable = math.max(0, safe_number(s.enemy_production_contestable, 1) - 0.20)
        s.vassalization_window = math.max(0, safe_number(s.vassalization_window, 0) - 0.30)
    elseif action.type == "chokehold_war" then
        s.border_seal_opportunity = math.max(0, safe_number(s.border_seal_opportunity, 0) - 0.25)
        s.hostile_neighbors_ratio = math.max(0, safe_number(s.hostile_neighbors_ratio, 0) - 0.08)
    elseif action.type == "exhaustion_manipulation" then
        s.war_exhaustion_abuse_window = math.max(0, safe_number(s.war_exhaustion_abuse_window, 0) - 0.35)
        s.upcoming_wars_risk = math.max(0, safe_number(s.upcoming_wars_risk, 0) - 0.07)
    elseif action.type == "attrition_abuse" then
        s.enemy_reinforcement_speed = math.max(0.1, safe_number(s.enemy_reinforcement_speed, 1) - 0.12)
        s.projected_war_losses_alloy_ratio = math.max(0, safe_number(s.projected_war_losses_alloy_ratio, 0) - 0.08)
    elseif action.type == "deception_feint" then
        s.enemy_fleet_out_of_position = math.min(1, safe_number(s.enemy_fleet_out_of_position, 0) + 0.18)
        s.enemy_chase_tendency = math.min(1, safe_number(s.enemy_chase_tendency, 0) + 0.12)
    elseif action.type == "intentional_retreat" then
        s.fortified_chokepoint_window = math.min(1, safe_number(s.fortified_chokepoint_window, 0) + 0.22)
        s.enemy_fleet_out_of_position = math.min(1, safe_number(s.enemy_fleet_out_of_position, 0) + 0.12)
    elseif action.type == "economic_raid" then
        s.enemy_replacement_rate = math.max(0.1, safe_number(s.enemy_replacement_rate, 1) - 0.18)
        s.enemy_trade_exposure = math.max(0, safe_number(s.enemy_trade_exposure, 0) - 0.10)
    elseif action.type == "multi_front_raid" then
        s.enemy_active_fronts = math.min(1, safe_number(s.enemy_active_fronts, 0) + 0.20)
        s.enemy_shipyard_exposure = math.min(1, safe_number(s.enemy_shipyard_exposure, 0) + 0.10)
    elseif action.type == "form_coalition" then
        s.anti_hegemon_sentiment = math.min(1, safe_number(s.anti_hegemon_sentiment, 0) + 0.20)
        s.hostile_neighbors_ratio = math.max(0, safe_number(s.hostile_neighbors_ratio, 0) - 0.08)
    elseif action.type == "containment_front" then
        s.top_empire_power_share = math.max(0, safe_number(s.top_empire_power_share, 0) - 0.04)
        s.enemy_in_another_war = math.min(1, safe_number(s.enemy_in_another_war, 0) + 0.15)
    elseif action.type == "embargo_hegemon" then
        s.top_empire_power_share = math.max(0, safe_number(s.top_empire_power_share, 0) - 0.03)
        s.enemy_economy_spiking = math.max(0, safe_number(s.enemy_economy_spiking, 0) - 0.12)
    elseif action.type == "prepare_crisis" then
        s.crisis_stockpile_ready = math.min(1, safe_number(s.crisis_stockpile_ready, 0) + 0.25)
        s.gateway_preposition = math.min(1, safe_number(s.gateway_preposition, 0) + 0.15)
        s.repeatable_tech_focus = math.min(1, safe_number(s.repeatable_tech_focus, 0) + 0.12)
        s.net_alloys = safe_number(s.net_alloys, 0) + 3 * horizon
    elseif action.type == "intercept_threat" then
        s.player_system_risk = math.max(0, safe_number(s.player_system_risk, 0) - 0.22)
        s.enemy_fleet_out_of_position = math.min(1, safe_number(s.enemy_fleet_out_of_position, 0) + 0.10)
    elseif action.type == "escort_player_fleet" then
        s.player_fleet_survival_probability = math.min(1, safe_number(s.player_fleet_survival_probability, 0.5) + 0.20)
        s.player_offensive_momentum = math.min(1, safe_number(s.player_offensive_momentum, 0) + 0.12)
    elseif action.type == "fire_brigade" then
        s.small_invasion_pressure = math.max(0, safe_number(s.small_invasion_pressure, 0) - 0.25)
        s.player_attention_split = math.max(0, safe_number(s.player_attention_split, 0) - 0.15)
    elseif action.type == "evacuation_guard" then
        s.player_fleet_survival_probability = math.min(1, safe_number(s.player_fleet_survival_probability, 0.5) + 0.25)
        s.player_retreat_losses = math.max(0, safe_number(s.player_retreat_losses, 0) - 0.20)
    elseif action.type == "stabilize_economy" then
        s.player_time_to_bankruptcy = math.max(0, safe_number(s.player_time_to_bankruptcy, 24) + 8)
        s.player_reinforcement_capability = math.min(1, safe_number(s.player_reinforcement_capability, 0.5) + 0.15)
    elseif action.type == "fortify_chokepoint" then
        s.chokepoint_integrity = math.min(1, safe_number(s.chokepoint_integrity, 0.4) + 0.25)
        s.crisis_path_to_player = math.max(0, safe_number(s.crisis_path_to_player, 0.5) - 0.15)
    elseif action.type == "build_forward_shipyard" then
        s.forward_shipyard_ratio = math.min(1, safe_number(s.forward_shipyard_ratio, 0.2) + 0.25)
        s.replacement_latency = math.max(0, safe_number(s.replacement_latency, 1) - 0.18)
    elseif action.type == "rotate_fleets" then
        s.fleet_rotation_readiness = math.min(1, safe_number(s.fleet_rotation_readiness, 0.3) + 0.22)
        s.fleet_attrition_rate = math.max(0, safe_number(s.fleet_attrition_rate, 0.4) - 0.14)
    elseif action.type == "target_crisis_nodes" then
        s.crisis_reinforcement_nodes = math.max(0, safe_number(s.crisis_reinforcement_nodes, 0.6) - 0.22)
        s.crisis_spread_rate = math.max(0, safe_number(s.crisis_spread_rate, 0.5) - 0.12)
    elseif action.type == "emergency_conversion" then
        s.net_alloys = safe_number(s.net_alloys, 0) + 5 * horizon
        s.net_consumer_goods = safe_number(s.net_consumer_goods, 0) - 2 * horizon
        s.net_energy = safe_number(s.net_energy, 0) + 2 * horizon
    elseif action.type == "hold_line_primary" then
        s.primary_line_integrity = math.min(1, safe_number(s.primary_line_integrity, 0.4) + 0.2)
        s.crisis_front_progress = math.max(0, safe_number(s.crisis_front_progress, 0.5) - 0.12)
    elseif action.type == "hold_line_secondary" then
        s.secondary_line_integrity = math.min(1, safe_number(s.secondary_line_integrity, 0.4) + 0.2)
        s.population_survival_probability = math.min(1, safe_number(s.population_survival_probability, 0.5) + 0.1)
    elseif action.type == "intentional_sacrifice" then
        s.time_gained_months = safe_number(s.time_gained_months, 0) + 8
        s.fleet_value_spent = safe_number(s.fleet_value_spent, 0) + 0.25
        s.crisis_front_progress = math.max(0, safe_number(s.crisis_front_progress, 0.5) - 0.1)
    end

    return s
end

function StratAI:_predict_enemy_response_policy(state, action, years)
    local rival_id = state.primary_rival
    local m = (rival_id and self.enemy_mind_models[rival_id]) or { risk_tolerance = 0.5, overreact = 0.5, turtle = 0.5, bad_war_accept = 0.5 }
    local border_pressure = normalize_ratio(state.border_pressure_window)
    local military_adv = safe_number(state.military_advantage, 0)
    local weakened_now = safe_number(state.net_alloys, 0) < 0 or military_adv < -0.05

    local policy = "status_quo"
    local confidence = 0.35

    if action.type == "colonize" then
        policy = "militarize"
        confidence = 0.55 + 0.25 * m.overreact
    elseif action.type == "build" and action.target == "research_lab" then
        policy = "alloy_rush"
        confidence = 0.50 + 0.20 * m.risk_tolerance
    elseif action.type == "delay_stockpile" or action.type == "seal_borders" then
        policy = "expansion"
        confidence = 0.45 + 0.25 * (1 - m.turtle)
    elseif weakened_now or action.type == "declare_war" then
        policy = "preemptive_war"
        confidence = 0.45 + 0.30 * math.max(border_pressure, m.bad_war_accept)
    elseif military_adv > 0.15 then
        policy = "defensive"
        confidence = 0.45 + 0.20 * m.turtle
    end

    return policy, clamp(confidence, 0.25, 0.95)
end

function StratAI:_apply_enemy_response(projected, policy, confidence, years)
    local s = deep_copy(projected)
    local horizon = clamp(safe_number(years, self.config.action_horizon_years), 1, 5)
    local c = clamp(safe_number(confidence, 0.5), 0, 1)

    if policy == "defensive" then
        s.enemy_counter_risk = safe_number(s.enemy_counter_risk, 0) + 0.18 * c
        s.enemy_reinforcement_speed = safe_number(s.enemy_reinforcement_speed, 1) + 0.08 * horizon * c
        s.projected_war_win_months = safe_number(s.projected_war_win_months, 36) + 4 * c
    elseif policy == "preemptive_war" then
        s.upcoming_wars_risk = clamp(safe_number(s.upcoming_wars_risk, 0) + 0.30 * c, 0, 1)
        s.net_alloys = safe_number(s.net_alloys, 0) - 4 * horizon * c
        s.military_advantage = safe_number(s.military_advantage, 0) - 0.15 * c
    elseif policy == "expansion" then
        s.enemy_pop_growth = safe_number(s.enemy_pop_growth, 0) + 0.20 * horizon * c
        s.expansion_paths_left = math.max(0, safe_number(s.expansion_paths_left, 0) - 1)
        s.positional_advantage = safe_number(s.positional_advantage, 0) - 0.08 * c
    elseif policy == "alloy_rush" then
        s.enemy_alloy_per_pop = safe_number(s.enemy_alloy_per_pop, 0) + 0.14 * horizon * c
        s.enemy_reinforcement_speed = safe_number(s.enemy_reinforcement_speed, 1) + 0.10 * c
        s.projected_war_losses_alloy_ratio = safe_number(s.projected_war_losses_alloy_ratio, 0) + 0.08 * c
    elseif policy == "militarize" then
        s.enemy_power = safe_number(s.enemy_power, 0) + 0.18 * horizon * c
        s.enemy_counter_risk = safe_number(s.enemy_counter_risk, 0) + 0.16 * c
        s.border_friction = safe_number(s.border_friction, 0) + 0.10 * c
    end

    return s
end

function StratAI:simulate_interaction(state, action, years)
    local projected = self:simulate_shallow(state, action, years)
    local policy, confidence = self:_predict_enemy_response_policy(state, action, years)
    local reacted = self:_apply_enemy_response(projected, policy, confidence, years)
    return reacted, { enemy_policy = policy, confidence = confidence }
end

function StratAI:commitment_window_score(state)
    local enemy_income = safe_number(state.enemy_alloy_income, safe_number(state.enemy_net_alloys, safe_number(state.enemy_alloy_per_pop, 0) * 10))
    local replacement_rate = math.max(1, safe_number(state.enemy_replacement_rate, safe_number(state.enemy_reinforcement_speed, 1) * 12))
    local border_access = normalize_ratio(state.border_access_window)
    local travel_time = safe_number(state.travel_time_to_front, safe_number(state.war_travel_time, 12))
    local reinforce_time = safe_number(state.enemy_reinforcement_time, safe_number(state.enemy_reinforcement_speed, 1) * 12)

    local low_replacement = (enemy_income < replacement_rate) and 1 or 0
    local timing_edge = (travel_time < reinforce_time) and 1 or 0
    local score = 0.65 * low_replacement + 0.20 * border_access + 0.15 * timing_edge

    if low_replacement == 1 and border_access > 0.55 and timing_edge == 1 then
        score = score + safe_number((self.config.strategic or {}).commitment_window_bonus, 0.40)
    end

    return clamp(score, 0, 1.5), {
        enemy_income = enemy_income,
        replacement_rate = replacement_rate,
        border_access = border_access,
        travel_time = travel_time,
        reinforce_time = reinforce_time
    }
end

function StratAI:_survivable_present(projected, action)
    local s = self.config.strategic or {}
    local energy_floor = safe_number(s.survivable_energy_floor, -20)
    local cg_floor = safe_number(s.survivable_cg_floor, -12)
    local stability_floor = safe_number(s.survivable_stability_floor, 0.35)

    local hard_fail = safe_number(projected.net_energy, 0) < energy_floor
        or safe_number(projected.net_consumer_goods, 0) < cg_floor
        or normalize_ratio(projected.stability_ratio) < stability_floor

    if hard_fail and action.type ~= "declare_war" then
        return false, "Present not survivable"
    end

    local commitment = self:commitment_window_score(projected)
    if hard_fail and action.type == "declare_war" and commitment < 0.85 then
        return false, "War rejected: no commitment window"
    end

    return true, "Present survivable"
end

function StratAI:clausewitz_what_if(state, action, phase)
    local cfg = self.config.clausewitz or {}
    local months = cfg.projection_months or { 12, 24, 36 }
    local total = 0
    local count = 0
    local traces = {}
    for _, m in ipairs(months) do
        if state.projection_month_cap and m > state.projection_month_cap then goto continue_month end
        local years = clamp(m / 12.0, 1, 5)
        local projected, reaction_meta = self:simulate_interaction(state, action, years)
        projected.rule_break_window = state.rule_break_window
        local s = self:evaluate_state(projected, phase)
        local commit_score = self:commitment_window_score(projected)
        local horizon_weight = 1 + (m / 36.0) * 0.2
        local weighted = (s + 0.20 * commit_score) * horizon_weight
        total = total + weighted
        count = count + 1
        traces[#traces + 1] = {
            months = m,
            score = s,
            weighted_score = weighted,
            commitment = commit_score,
            enemy_policy = reaction_meta.enemy_policy,
            reaction_confidence = reaction_meta.confidence
        }
        ::continue_month::
    end
    local avg = (count > 0) and (total / count) or self:evaluate_state(state, phase)
    return avg, traces
end
function StratAI:explain_eval_snapshot(state)
    local e = self.last_eval and self.last_eval.components or {}
    return {
        total = self.last_eval and self.last_eval.total or 0,
        bottleneck = state.active_bottleneck,
        failure_shortest = (state.failure_clocks or {}).shortest,
        eco = e.Eco or 0,
        mil = e.Mil or 0,
        tech = e.Tech or 0,
        risk = e.Risk or 0,
        irreversibility = (e.Irreversibility or 0) + (e.ClausewitzIrreversibility or 0),
        meta_strategy = self.strongest_meta and self.strongest_meta.strategy_name or "none",
        counter_meta = self.active_counter_meta and self.active_counter_meta.our_strategy_name or "none",
        opponent_detected = self.active_counter_meta and "Meta spammer countered" or "No counter needed"
    }
end

function StratAI:campaign_templates()
    return {
        economic_boom = { focus = { "build", "research", "colonize" }, risk = 0.35, doctrine = "balanced" },
        defensive_turtle = { focus = { "seal_borders", "delay_stockpile", "redesign_fleet" }, risk = 0.25, doctrine = "balanced" },
        tech_rush = { focus = { "research", "build" }, risk = 0.4, doctrine = "balanced" },
        naval_supremacy = { focus = { "build", "redesign_fleet", "declare_war" }, risk = 0.58, doctrine = "anti_evasion" },
        opportunistic_war = { focus = { "declare_war", "seal_borders", "seek_vassalization" }, risk = 0.63, doctrine = "anti_shield" },
        containment_war = { focus = { "tech_denial", "declare_war", "probe_skirmish" }, risk = 0.55, doctrine = "anti_armor" },
        vassalization_campaign = { focus = { "seek_vassalization", "vassalization_chain", "probe_diplomacy" }, risk = 0.5, doctrine = "balanced" }
    }
end

function StratAI:_plan_bias_multiplier(action, plan)
    local p = self:campaign_templates()[plan] or self:campaign_templates().economic_boom
    for _, t in ipairs(p.focus or {}) do
        if action.type == t then return 1.18 end
    end
    return 0.96
end

function StratAI:select_campaign_plan(state, phase)
    local plans = self:campaign_templates()
    local best, best_score = "economic_boom", -math.huge
    local years = clamp(safe_number((self.config.strategic or {}).campaign_horizon_years, 8), 3, 12)

    for name, _ in pairs(plans) do
        local proxy = { type = "delay_stockpile" }
        if name == "tech_rush" then proxy = { type = "research", target = "military_tech" }
        elseif name == "naval_supremacy" then proxy = { type = "redesign_fleet" }
        elseif name == "opportunistic_war" then proxy = { type = "declare_war" }
        elseif name == "containment_war" then proxy = { type = "tech_denial" }
        elseif name == "vassalization_campaign" then proxy = { type = "seek_vassalization" }
        elseif name == "defensive_turtle" then proxy = { type = "seal_borders" } end

        local projected, reaction = self:simulate_interaction(state, proxy, years)
        local base = self:evaluate_state(projected, phase)
        local pressure = self:counter_strategy_pressure(state, proxy)
        local logistics = self:logistics_advantage_score(projected)
        local opp = self:opportunity_window_score(projected)
        local dip = self:diplomatic_manipulation_score(projected)
        local longh = self:long_horizon_specialization_score(projected, name)
        local total = base + pressure + logistics + opp + dip + longh + safe_number(reaction.confidence, 0) * 0.2

        if total > best_score then best, best_score = name, total end
    end

    self.campaign_memory.active_plan = best
    return best, best_score
end

function StratAI:counter_strategy_pressure(state, action)
    local projected = self:simulate_shallow(state, action, 2)
    local paths = {
        status_quo = self:evaluate_state(self:_apply_enemy_response(projected, "defensive", 0.5, 2)),
        pivot_military = self:evaluate_state(self:_apply_enemy_response(projected, "preemptive_war", 0.6, 2)),
        pivot_tech = self:evaluate_state(self:_apply_enemy_response(projected, "alloy_rush", 0.55, 2)),
        pivot_alliance = self:evaluate_state(self:_apply_enemy_response(projected, "expansion", 0.5, 2))
    }
    local worst = math.huge
    for _, v in pairs(paths) do if v < worst then worst = v end end
    local avg = 0
    for _, v in pairs(paths) do avg = avg + v end
    avg = avg / 4
    return clamp((avg - worst) * 0.08, -0.4, 0.8)
end

function StratAI:logistics_advantage_score(state)
    local travel_time = safe_number(state.travel_time_to_front, safe_number(state.war_travel_time, 12))
    local enemy_reinforce = safe_number(state.enemy_reinforcement_time, safe_number(state.enemy_reinforcement_speed, 1) * 12)
    local shipyard = safe_number(state.shipyard_throughput, safe_number(state.our_reinforcement_speed, 1))
    local replacement = math.max(0.1, safe_number(state.replacement_rate, safe_number(state.net_alloys, 0) + shipyard))
    local enemy_replace = math.max(0.1, safe_number(state.enemy_replacement_rate, safe_number(state.enemy_reinforcement_speed, 1) * 10))
    local sustain = (replacement / enemy_replace) * (enemy_reinforce / math.max(1, travel_time))
    return clamp((sustain - 1) * safe_number((self.config.strategic or {}).logistics_weight, 0.30), -0.6, 1.0)
end

function StratAI:opportunity_window_score(state)
    local flags = {
        normalize_ratio(state.enemy_fleet_out_of_position),
        normalize_ratio(state.enemy_in_another_war),
        normalize_ratio(state.enemy_recently_colonized),
        normalize_ratio(state.enemy_economy_spiking),
        normalize_ratio(state.enemy_fleet_upgrading),
        normalize_ratio(state.enemy_tech_transition)
    }
    local hits = 0
    for _, v in ipairs(flags) do if v > 0.55 then hits = hits + 1 end end
    local bonus = (hits >= 3) and 1.0 or ((hits == 2) and 0.5 or 0)
    return bonus * safe_number((self.config.strategic or {}).opportunity_window_boost, 0.35)
end

function StratAI:diplomatic_manipulation_score(state)
    local proxy = normalize_ratio(state.proxy_war_window)
    local coalition = normalize_ratio(state.coalition_bait_window)
    local buffer = normalize_ratio(state.buffer_state_window)
    local manipulate = 0.45 * proxy + 0.35 * coalition + 0.20 * buffer
    return clamp(manipulate * safe_number((self.config.strategic or {}).diplomatic_manipulation_weight, 0.18), -0.25, 0.7)
end

function StratAI:long_horizon_specialization_score(state, plan)
    local h = safe_number((self.config.strategic or {}).long_horizon_weight, 0.22)
    if plan == "tech_rush" then
        return h * logistic_like(safe_number(state.tech_tier, 1) - safe_number(state.enemy_tech_tier, 1), 1.2)
    elseif plan == "naval_supremacy" then
        return h * logistic_like(safe_number(state.net_alloys, 0) + safe_number(state.military_advantage, 0), 12)
    elseif plan == "defensive_turtle" then
        return h * logistic_like(safe_number(state.avg_planet_stability, 50) - 45, 8)
    elseif plan == "vassalization_campaign" then
        return h * logistic_like(safe_number(state.vassalization_window, 0) - 0.4, 0.35)
    end
    return h * logistic_like(safe_number(state.net_energy, 0) + safe_number(state.net_alloys, 0), 20)
end

function StratAI:war_termination_score(state)
    local gains = normalize_ratio(state.claim_value_gained) + normalize_ratio(state.frontline_secured)
    local risks = normalize_ratio(state.overextension_risk) + normalize_ratio(state.third_party_war_risk) + normalize_ratio(state.war_exhaustion_ratio)
    return gains - risks
end

function StratAI:hidden_info_confidence(state)
    local sigma = safe_number(state.enemy_fleet_power_sigma, safe_number(state.intel_uncertainty, 0) * 0.5)
    return clamp(1 - sigma, 0.1, 0.95)
end

function StratAI:update_meta_learning(state, action, score)
    local out = self.campaign_memory.meta
    local key = (action and action.type) or "none"
    out.spikes[key] = safe_number(out.spikes[key], 0)
    out.collapses[key] = safe_number(out.collapses[key], 0)
    if safe_number(score, 0) > 1.5 then out.spikes[key] = out.spikes[key] + 1 end
    if safe_number(score, 0) < -1.5 then out.collapses[key] = out.collapses[key] + 1 end
    if normalize_ratio(state.empire_collapse_signal) > 0.6 then
        out.losses[key] = safe_number(out.losses[key], 0) + 1
    end
end

function StratAI:update_player_profile(state)
    local p = self.player_profile
    local i = self.config.inertia
    p.years_observed = safe_number(state.year, p.years_observed)

    p.rush = blend(p.rush, normalize_ratio(state.player_early_war_rate), i)
    p.turtle = blend(p.turtle, normalize_ratio(state.player_turtle_ratio), i)
    p.tech_greedy = blend(p.tech_greedy, normalize_ratio(state.player_research_focus), i)
    p.diplomacy = blend(p.diplomacy, normalize_ratio(state.player_diplomatic_activity), i)
    p.fleet_overbuild = blend(p.fleet_overbuild, normalize_ratio(state.player_fleet_overbuild), i)
    p.border_neglect = blend(p.border_neglect, normalize_ratio(state.player_border_neglect), i)

    local scores = {
        Aggressor = p.rush * 0.55 + p.fleet_overbuild * 0.25 + (1 - p.turtle) * 0.20,
        Builder = p.turtle * 0.45 + (1 - p.rush) * 0.25 + (1 - p.border_neglect) * 0.30,
        Diplomat = p.diplomacy * 0.7 + (1 - p.rush) * 0.3,
        Snowballer = p.tech_greedy * 0.45 + p.fleet_overbuild * 0.30 + p.rush * 0.25,
        Roleplayer = p.diplomacy * 0.3 + p.turtle * 0.4 + (1 - p.fleet_overbuild) * 0.3,
        Opportunist = p.rush * 0.35 + p.tech_greedy * 0.35 + p.border_neglect * 0.30
    }
    local best, bv = "Opportunist", -1
    for k, v in pairs(scores) do if v > bv then best, bv = k, v end end
    p.archetype = best
    self.player_profile = p
    return p
end

function StratAI:profile_counter_bias(action)
    local p = self.player_profile or {}
    local t = p.archetype or "Opportunist"
    if t == "Aggressor" then
        if action.type == "seal_borders" or action.type == "redesign_fleet" then return 1.18 end
        if action.type == "probe_diplomacy" then return 0.92 end
    elseif t == "Builder" then
        if action.type == "tech_denial" or action.type == "declare_war" then return 1.12 end
    elseif t == "Diplomat" then
        if action.type == "probe_diplomacy" or action.type == "seek_vassalization" then return 1.14 end
    elseif t == "Snowballer" then
        if action.type == "declare_war" or action.type == "containment_front" then return 1.16 end
    end
    return 1.0
end

function StratAI:deception_score(state, action)
    local w = safe_number((self.config.strategic or {}).deception_weight, 0.12)
    local bait = normalize_ratio(state.enemy_chase_tendency) * normalize_ratio(state.sensor_shadow_window)
    local weak_border = normalize_ratio(state.intentional_weak_border_window)
    local ambush = normalize_ratio(state.fortified_chokepoint_window)
    local retreat = normalize_ratio(state.intentional_retreat_window)
    local base = 0.35 * bait + 0.25 * weak_border + 0.25 * ambush + 0.15 * retreat
    if action.type == "deception_feint" or action.type == "intentional_retreat" then base = base + 0.35 end
    return clamp(base * w, -0.2, 0.7)
end

function StratAI:crisis_preparation_score(state, action)
    local year = safe_number(state.year, 2300)
    local late = (year >= safe_number(state.crisis_prep_year, 2360)) and 1 or 0
    local prep = normalize_ratio(state.crisis_stockpile_ready) + normalize_ratio(state.gateway_preposition) + normalize_ratio(state.repeatable_tech_focus)
    local w = safe_number((self.config.strategic or {}).crisis_prep_weight, 0.22)
    if action.type == "prepare_crisis" or action.type == "delay_stockpile" then prep = prep + 0.4 end
    return late * clamp((prep / 3) * w, 0, 0.8)
end

function StratAI:strategic_patience_score(state, action)
    local exhausted = normalize_ratio(state.enemy_recent_war_exhaustion)
    local years_since = safe_number(state.enemy_years_since_major_war, 0)
    local wait_target = safe_number((self.config.strategic or {}).patience_years, 10)
    local ready_window = (years_since >= wait_target * 0.8 and years_since <= wait_target * 1.4) and 1 or 0
    if action.type == "delay_stockpile" then
        return clamp(exhausted * (1 - ready_window) * 0.25, 0, 0.4)
    elseif action.type == "declare_war" then
        return clamp(exhausted * ready_window * 0.45, -0.1, 0.6)
    end
    return 0
end

function StratAI:tech_path_anticipation_score(state, action)
    local researchers = normalize_ratio(state.enemy_researcher_density)
    local alloys = normalize_ratio(1 - state.enemy_alloy_focus)
    local fleet = normalize_ratio(1 - state.enemy_fleet_ratio)
    local incoming_spike = clamp((researchers + alloys + fleet) / 3, 0, 1)
    local w = safe_number((self.config.strategic or {}).tech_anticipation_weight, 0.16)
    if action.type == "declare_war" or action.type == "tech_denial" then
        return incoming_spike * w
    end
    return 0
end

function StratAI:strategic_grudge_score(state, action)
    local id = state.primary_rival or "unknown"
    local g = self.strategic_memory.grudges[id] or 0
    if action.type == "declare_war" or action.type == "containment_front" then
        return clamp(g * 0.12, 0, 0.6)
    end
    if action.type == "probe_diplomacy" then
        return -clamp(g * 0.05, 0, 0.3)
    end
    return 0
end

function StratAI:multi_front_score(state, action)
    local raid = normalize_ratio(state.enemy_trade_exposure) + normalize_ratio(state.enemy_shipyard_exposure)
    local fronts = normalize_ratio(state.enemy_active_fronts)
    if action.type == "multi_front_raid" then
        return clamp((raid * 0.6 + fronts * 0.4) * 0.6, 0, 0.8)
    end
    return 0
end

function StratAI:economic_warfare_score(state, action)
    local heartland = normalize_ratio(state.enemy_forge_world_exposure) + normalize_ratio(state.enemy_trade_hub_exposure) + normalize_ratio(state.enemy_megastructure_exposure)
    if action.type == "economic_raid" then
        return clamp((heartland / 3) * 0.75, 0, 0.9)
    end
    return 0
end

function StratAI:coalition_engineering_score(state, action)
    local target = self.strategic_memory.strongest_empire
    local strongest_is_player = (target ~= nil and target == (state.player_empire_id or "player")) and 1 or 0
    local anti = normalize_ratio(state.anti_hegemon_sentiment)
    if action.type == "form_coalition" or action.type == "probe_diplomacy" then
        return clamp((strongest_is_player * 0.6 + anti * 0.4) * 0.7, 0, 0.9)
    end
    return 0
end

function StratAI:power_spike_score(state, action)
    local spike = normalize_ratio(state.new_battleship_tech) * 0.3 + normalize_ratio(state.enemy_fleet_upgrading) * 0.3 + normalize_ratio(state.enemy_recent_war_exhaustion) * 0.2 + normalize_ratio(state.alloy_peak_window) * 0.2
    if action.type == "declare_war" then return clamp(spike * 0.9, 0, 1) end
    return 0
end

function StratAI:anti_snowball_score(state, action)
    local share = normalize_ratio(state.top_empire_power_share)
    local hegemon = (share > 0.42) and 1 or 0
    local w = safe_number((self.config.strategic or {}).anti_snowball_weight, 0.20)
    if action.type == "form_coalition" or action.type == "containment_front" or action.type == "embargo_hegemon" then
        return hegemon * w * (0.6 + share)
    end
    return 0
end

function StratAI:update_strategic_memory(state)
    local rival = state.primary_rival
    if rival then
        local g = self.strategic_memory.grudges[rival] or 0
        if normalize_ratio(state.rival_betrayed_us) > 0.5 then g = g + 0.25 end
        if normalize_ratio(state.rival_invaded_us) > 0.5 then g = g + 0.2 end
        if normalize_ratio(state.rival_humiliated_us) > 0.5 then g = g + 0.2 end
        if normalize_ratio(state.rival_helped_us) > 0.5 then g = g - 0.15 end
        self.strategic_memory.grudges[rival] = clamp(0.98 * g, 0, 3)
    end

    local strongest = state.strongest_empire_id or state.primary_rival
    self.strategic_memory.strongest_empire = strongest
end

function StratAI:infer_player_intent(state)
    local p = self.player_profile or {}
    local goal = "economy"
    if normalize_ratio(state.player_emergency_ship_spam) > 0.55 or normalize_ratio(state.player_order_cancellations) > 0.55 then
        goal = "panic"
    elseif (p.tech_greedy or 0.5) > 0.62 then
        goal = "teching"
    elseif (p.turtle or 0.5) > 0.62 then
        goal = "turtling"
    elseif (p.rush or 0.5) > 0.6 then
        goal = "conquest"
    end

    local risk = clamp(0.35 + 0.4 * normalize_ratio(state.player_emergency_ship_spam) + 0.25 * normalize_ratio(state.player_border_neglect), 0, 1)
    local attention = "core"
    if normalize_ratio(state.player_focus_border) > 0.55 then attention = "border" end
    if normalize_ratio(state.player_focus_frontline) > 0.55 then attention = "frontline" end

    local intent = { goal = goal, risk = risk, attention = attention }
    self.friend_state.intent = intent
    return intent
end

function StratAI:friend_mode_support_score(state, action, intent)
    local w = safe_number((self.config.friend_mode or {}).support_weight, 0.35)
    local crisis_path = normalize_ratio(state.crisis_path_to_player)
    local player_risk = normalize_ratio(state.player_system_risk)
    local bankruptcy = normalize_ratio(1 - (safe_number(state.player_time_to_bankruptcy, 24) / 36))
    local reinf_gap = normalize_ratio(1 - safe_number(state.player_reinforcement_capability, 0.5))
    local survival = normalize_ratio(state.player_fleet_survival_probability)
    local intervention = normalize_ratio(state.ai_intervention_success)

    local s = 0
    if action.type == "intercept_threat" then s = s + 0.6 * crisis_path + 0.4 * player_risk end
    if action.type == "stabilize_economy" then s = s + 0.55 * bankruptcy + 0.45 * reinf_gap end
    if action.type == "escort_player_fleet" then s = s + 0.55 * normalize_ratio(state.player_attack_commitment) + 0.45 * (1 - survival) end
    if action.type == "fire_brigade" then s = s + normalize_ratio(state.small_invasion_pressure) end
    if action.type == "evacuation_guard" then s = s + 0.7 * (1 - survival) + 0.3 * intervention end

    if intent.goal == "panic" and (action.type == "intercept_threat" or action.type == "evacuation_guard") then s = s + 0.2 end
    if intent.goal == "teching" and action.type == "stabilize_economy" then s = s + 0.15 end
    if intent.goal == "conquest" and action.type == "escort_player_fleet" then s = s + 0.12 end

    if action.type == "declare_war" then s = s - 0.35 end -- Friend mode should support, not carry
    return clamp(s * w, -0.5, 0.9)
end

function StratAI:friend_mode_rescue_trigger(state)
    local cfg = self.config.friend_mode or {}
    local survival = normalize_ratio(state.player_fleet_survival_probability)
    local success = normalize_ratio(state.ai_intervention_success)
    return survival < safe_number(cfg.rescue_survival_threshold, 0.28) and success > safe_number(cfg.rescue_success_threshold, 0.58)
end

function StratAI:friend_mode_notices(state, action, intent)
    local notices = {}
    if action.type == "intercept_threat" then notices[#notices + 1] = "We are intercepting a threat heading toward your core systems." end
    if action.type == "evacuation_guard" then notices[#notices + 1] = "Hold position. We are covering your retreat route." end
    if action.type == "stabilize_economy" then notices[#notices + 1] = "Your alloy reserves are strained. We will stabilize supply lanes." end
    if self:friend_mode_rescue_trigger(state) then notices[#notices + 1] = "Emergency jump approved. Reinforcements incoming." end
    if #notices == 0 and intent.goal == "panic" then notices[#notices + 1] = "Stay focused. We will hold this flank while you recover." end
    return notices
end

function StratAI:apply_protective_ignorance(score, state, action)
    if not ((state.friend_mode == true) or ((self.config.friend_mode or {}).enabled == true)) then return score end
    local pi = safe_number((self.config.friend_mode or {}).protective_ignorance, 0.10)
    local high_certainty = normalize_ratio(1 - safe_number(state.intel_uncertainty, 0))
    local damp = 1 - pi * high_certainty
    if action.type == "intercept_threat" and safe_number(self.friend_state.rescue_cooldown, 0) > 0 then
        damp = damp * 0.9
    end
    return score * clamp(damp, 0.75, 1.0)
end

function StratAI:crisis_system_doom_timer(state)
    local distance = safe_number(state.distance_from_crisis, 6)
    local access = safe_number(state.hyperlane_accessibility, 0.5) * 8
    local defense = safe_number(state.defensive_strength, 0.5) * 6
    local spread = safe_number(state.crisis_spread_rate, 0.5) * 10
    return clamp(distance + access + defense - spread, 1, 120)
end

function StratAI:galactic_collapse_eta(state)
    local local_eta = self:crisis_system_doom_timer(state)
    local front = 24 * (1 - normalize_ratio(state.crisis_front_progress))
    return math.max(1, math.min(local_eta, front))
end

function StratAI:minimal_chokepoint_cut_score(state)
    local cut_size = math.max(1, safe_number(state.crisis_cutset_size, 3))
    local lane_density = math.max(1, safe_number(state.hyperlane_density, 3))
    local fort = normalize_ratio(state.chokepoint_integrity)
    return clamp((lane_density / cut_size) * 0.15 + fort * 0.25, 0, 0.9)
end

function StratAI:crisis_spawn_prediction_score(state, action)
    local likely_next = normalize_ratio(state.predicted_crisis_next_system_prob)
    if action.type == "intercept_threat" or action.type == "hold_line_primary" then
        return likely_next * 0.45
    end
    return 0
end

function StratAI:crisis_target_priority_score(state, action)
    local nodes = normalize_ratio(state.crisis_reinforcement_nodes)
    if action.type == "target_crisis_nodes" then return nodes * 0.65 end
    return 0
end

function StratAI:reflex_override_action(state)
    if normalize_ratio(state.fleet_trap_risk) > 0.72 then return { type = "rotate_fleets" }, "reflex_override_trap_avoidance" end
    if normalize_ratio(state.incoming_superior_fleet) > 0.75 then return { type = "hold_line_secondary" }, "reflex_override_fallback" end
    if normalize_ratio(state.player_fleet_survival_probability) < 0.18 and ((state.friend_mode == true) or ((self.config.friend_mode or {}).enabled == true)) then
        return { type = "evacuation_guard" }, "reflex_override_emergency_rescue"
    end
    return nil, nil
end

function StratAI:operational_line_score(state, action)
    local w = safe_number((self.config.strategic or {}).fallback_line_weight, 0.22)
    local p = normalize_ratio(state.primary_line_integrity)
    local s = normalize_ratio(state.secondary_line_integrity)
    if action.type == "hold_line_primary" then return (1 - p) * w end
    if action.type == "hold_line_secondary" then return (1 - s) * w end
    return 0
end

function StratAI:intentional_sacrifice_score(state, action)
    if action.type ~= "intentional_sacrifice" then return 0 end
    local tg = safe_number(state.time_gained_months, 0)
    local fv = safe_number(state.fleet_value_spent, 0.25)
    local ratio = tg / math.max(0.1, fv * 12)
    local w = safe_number((self.config.strategic or {}).sacrifice_weight, 0.28)
    return clamp((ratio - 1) * w, -0.4, 0.9)
end

function StratAI:crisis_total_war_score(state, action)
    local eta = self:galactic_collapse_eta(state)
    local th = safe_number((self.config.strategic or {}).crisis_total_war_eta, 24)
    if eta > th then return 0 end
    local urgency = clamp((th - eta) / math.max(1, th), 0, 1)
    if action.type == "emergency_conversion" or action.type == "build_forward_shipyard" or action.type == "target_crisis_nodes" then
        return urgency * 0.7
    end
    if action.type == "colonize" then return -urgency * 0.5 end
    return 0
end

function StratAI:_log_eval_components(state)
    self.eval_component_log = self.eval_component_log or {}
    local max_log = math.max(8, safe_number(((self.config.telemetry or {}).eval_component_log_size), 64))
    local snapshot = {
        year = safe_number(state and state.game_year, safe_number(state and state.year, 0)),
        total = self.last_eval and safe_number(self.last_eval.total, 0) or 0,
        components = deep_copy((self.last_eval and self.last_eval.components) or {})
    }
    self.eval_component_log[#self.eval_component_log + 1] = snapshot
    while #self.eval_component_log > max_log do
        table.remove(self.eval_component_log, 1)
    end
    return snapshot
end

function StratAI:_fleet_mix_score(state)
    local f = state.fleet_mix or {}
    local bs = normalize_ratio(f.battleship or state.ship_class_battleship or 0)
    local cv = normalize_ratio(f.corvette or state.ship_class_corvette or 0)
    local ratio_cap = normalize_ratio(((self.config.fleet or {}).max_battleship_ratio) or 0.35)
    local min_corvette = normalize_ratio(((self.config.fleet or {}).min_corvette_ratio) or 0.20)

    local spam_penalty = math.max(0, bs - ratio_cap) * 1.6
    local low_screen_penalty = math.max(0, min_corvette - cv) * 1.1
    local corvette_bloat_penalty = math.max(0, cv - 0.75) * 0.8
    local adaptive_bonus = 0
    if self.active_counter_meta and self.active_counter_meta.our_strategy_name == "tracking_battleship_wall" then
        adaptive_bonus = adaptive_bonus + 0.08
    elseif self.active_counter_meta and self.active_counter_meta.our_strategy_name == "pd_corvette_swarm" then
        adaptive_bonus = adaptive_bonus + 0.10
    end

    return clamp(adaptive_bonus - spam_penalty - low_screen_penalty - corvette_bloat_penalty, -0.75, 0.25)
end

function StratAI:_eco_gap_multiplier(state)
    local enemy = math.max(1, safe_number(state.enemy_total_economy, 0))
    local ours = math.max(1, safe_number(state.our_total_economy, 0))
    local ratio = enemy / ours
    if ratio >= 5.0 then return 1.35, ratio end
    if ratio >= 3.0 then return 1.20, ratio end
    return 1.0, ratio
end

function StratAI:build_dynamic_meta_templates(state)
    local out = {}
    local templates = state.dynamic_meta_templates or {}
    for _, t in ipairs(templates) do
        if t and t.strategy_name and t.signature_conditions then
            out[#out + 1] = t
        end
    end

    local steam = state.steam_meta_signals or {}
    if steam.bio_rush_confidence and steam.bio_rush_confidence > 0.6 then
        out[#out + 1] = {
            phase = "any",
            signature_conditions = { game_year_min = 2230, bio_ascension = true },
            strategy_name = "steam_bio_rush_counterfeed",
            weight_modifiers = { Mil = 1.35, Eco = 1.10, Tech = 0.95 },
            confidence = clamp(safe_number(steam.bio_rush_confidence, 0.65), 0.5, 0.95)
        }
    end
    if steam.virtuality_confidence and steam.virtuality_confidence > 0.6 then
        out[#out + 1] = {
            phase = "any",
            signature_conditions = { game_year_min = 2235, machine_age_virtuality = true },
            strategy_name = "steam_virtuality_denial_feed",
            weight_modifiers = { Mil = 1.25, Tech = 1.15, Pos = 1.10 },
            confidence = clamp(safe_number(steam.virtuality_confidence, 0.65), 0.5, 0.95)
        }
    end

    return out
end

function StratAI:_action_matches_pattern(action, pattern)
    if not action or not pattern then return false end
    local key = (action.type or "") .. "_" .. (action.target or "")
    local p = tostring(pattern):gsub("%+", "")
    return key:find(p, 1, true) ~= nil
end

function StratAI:_apply_weight_blend(score, action, mods, blend)
    local m = mods or {}
    local b = clamp(safe_number(blend, 0), 0, 1)
    local mul = 1.0
    if action.type == "declare_war" or action.type == "containment_front" then mul = mul + b * ((m.Mil or 1) - 1) end
    if action.type == "research" or action.type == "tech_denial" then mul = mul + b * ((m.Tech or 1) - 1) end
    if action.type == "build" or action.type == "delay_stockpile" then mul = mul + b * ((m.Eco or 1) - 1) end
    if action.type == "seal_borders" or action.type == "fortify_chokepoint" then mul = mul + b * ((m.Pos or 1) - 1) end
    if action.type == "hold_line_primary" or action.type == "hold_line_secondary" then mul = mul + b * ((m.Stab or 1) - 1) end
    return score * clamp(mul, 0.7, 1.8)
end

function StratAI:_update_meta_effectiveness(meta_name, counter_name, score)
    if meta_name and meta_name ~= "none" then
        local b = self.meta_effectiveness.by_meta
        b[meta_name] = b[meta_name] or { n = 0, reward = 0 }
        b[meta_name].n = b[meta_name].n + 1
        b[meta_name].reward = 0.97 * b[meta_name].reward + 0.03 * safe_number(score, 0)
    end
    if counter_name and counter_name ~= "none" then
        local b = self.meta_effectiveness.by_counter
        b[counter_name] = b[counter_name] or { n = 0, reward = 0 }
        b[counter_name].n = b[counter_name].n + 1
        b[counter_name].reward = 0.97 * b[counter_name].reward + 0.03 * safe_number(score, 0)
    end
end

function StratAI:select_best_action(state, phase)
    local actions = self:generate_actions(state)
    local best_action = nil
    local best_score = -math.huge

    local curiosity_on, curiosity_meta = self:curiosity_mode(state)
    local bottleneck, bottleneck_val = self:detect_bottleneck(state)
    local active_bottleneck = state.active_bottleneck or bottleneck

    local wait_score = self:clausewitz_what_if(state, { type = "delay_stockpile" }, phase)
    local future_priority = clamp(safe_number((self.config.strategic or {}).future_priority, 0.92), 0.5, 0.99)
    local campaign_plan, _campaign_score = self:select_campaign_plan(state, phase)
    local intel_conf = self:hidden_info_confidence(state)
    local active_meta = self:select_meta_strategy(state)
    local counter_meta = self.active_counter_meta

    if active_meta and active_meta.bottleneck_override_suggestion then active_bottleneck = active_meta.bottleneck_override_suggestion end
    if counter_meta and counter_meta.bottleneck_override_suggestion then active_bottleneck = counter_meta.bottleneck_override_suggestion end
    if active_meta and active_meta.curiosity_block_exploration then curiosity_on = false end
    local in_friend_mode = (state.friend_mode == true) or ((self.config.friend_mode or {}).enabled == true)
    local player_intent = self:infer_player_intent(state)
    local crisis_eta = self:galactic_collapse_eta(state)
    local eco_gap_multiplier = select(1, self:_eco_gap_multiplier(state))
    local aggression = clamp(safe_number(self.config.aggression_slider, 1.0), 0.5, 2.0)

    local reflex_action, reflex_reason = self:reflex_override_action(state)
    if reflex_action then
        self:record_decision_why(reflex_action, reflex_reason, state)
        return reflex_action, wait_score + 0.35
    end

    for _, action in ipairs(actions) do
        local present = self:simulate_shallow(state, action, 1)
        present.rule_break_window = state.rule_break_window

        local hard_ok, hard_reason = self:hard_no_guardrails(present, action)
        if not hard_ok then
            self:record_decision_why(action, hard_reason, state)
            goto continue
        end

        local safe, _ = self:panic_guardrails(present, action)
        if not safe then
            goto continue
        end

        local survivable, survivable_reason = self:_survivable_present(present, action)
        if not survivable then
            self:record_decision_why(action, survivable_reason, state)
            goto continue
        end

        local projected = self:simulate_interaction(state, action, self.config.action_horizon_years)
        if action.type == "declare_war" then
            local ok, why = self:should_start_war(projected)
            if not ok then
                self:record_decision_why(action, why, state)
                goto continue
            end
        end
        if state.at_war and action.type == "declare_war" then
            local term = self:war_termination_score(projected)
            if term < -safe_number((self.config.strategic or {}).war_termination_margin, 0.12) then
                self:record_decision_why(action, "War termination logic: avoid overextension", state)
                goto continue
            end
        end

        local future_score, what_if_trace = self:clausewitz_what_if(state, action, phase)
        action.what_if_trace = what_if_trace

        local present_score = self:evaluate_state(present, phase)
        local score = future_priority * future_score + (1 - future_priority) * present_score
        if eco_gap_multiplier > 1 and (action.type == "build" or action.type == "research" or action.type == "delay_stockpile") then
            score = score * eco_gap_multiplier
        end
        score = score * self:_plan_bias_multiplier(action, campaign_plan)
        score = score * self:meta_action_bias(action, projected)

        if active_meta then
            score = self:_apply_weight_blend(score, action, active_meta.weight_modifiers, 0.22 * safe_number(active_meta.confidence, 0.5))
            for _, pat in ipairs(active_meta.priority_boost_actions or {}) do
                if self:_action_matches_pattern(action, pat) then
                    score = score + 0.20 * safe_number(active_meta.confidence, 0.5)
                    break
                end
            end
        end

        if counter_meta then
            local conf = clamp(self.opponent_meta_confidence or 0, 0, 1)
            for _, pat in ipairs(counter_meta.our_priority_boost_actions or {}) do
                if self:_action_matches_pattern(action, pat) then
                    score = score + 0.25 * conf
                    break
                end
            end
            score = self:_apply_weight_blend(score, action, counter_meta.our_weight_modifiers, 0.30 * conf)
            if counter_meta.doctrine_override and action.type == "redesign_fleet" then
                score = score + 0.15
            end
        end
        score = self:uncertainty_adjusted_score(score, projected)
        score = score * (0.75 + 0.25 * intel_conf)
        score = score - self:identity_consistency_penalty(action)

        score = score + safe_number((self.config.strategic or {}).profile_adaptation_weight, 0.18) * (self:profile_counter_bias(action) - 1)
        score = score + self:deception_score(projected, action)
        score = score + self:crisis_preparation_score(projected, action)
        score = score + self:strategic_patience_score(projected, action)
        score = score + self:tech_path_anticipation_score(projected, action)
        score = score + self:strategic_grudge_score(projected, action)
        score = score + self:multi_front_score(projected, action)
        score = score + self:economic_warfare_score(projected, action)
        score = score + self:coalition_engineering_score(projected, action)
        score = score + self:power_spike_score(projected, action)
        score = score + self:anti_snowball_score(projected, action)
        if in_friend_mode then
            score = score + self:friend_mode_support_score(projected, action, player_intent)
            score = self:apply_protective_ignorance(score, projected, action)
        end

        score = score + self:crisis_total_war_score(projected, action)
        score = score + self:crisis_counter_action_bonus(projected, action)
        score = score + self:minimal_chokepoint_cut_score(projected)
        score = score + self:crisis_spawn_prediction_score(projected, action)
        score = score + self:crisis_target_priority_score(projected, action)
        score = score + self:operational_line_score(projected, action)
        score = score + self:intentional_sacrifice_score(projected, action)

        if projected.rule_break_window and (action.type == "declare_war" or action.type == "redesign_fleet") then
            score = score + 0.08
        end

        if action.type == "declare_war" then score = score * aggression end

        if curiosity_on and self:is_exploratory_action(action) then
            local bonus, reason = self:curiosity_bonus(projected, action, phase)
            local cm = 1.0
            if active_meta and active_meta.curiosity_bonus_multiplier then cm = cm * safe_number(active_meta.curiosity_bonus_multiplier, 1.0) end
            if counter_meta and counter_meta.curiosity_bonus_multiplier then cm = cm * safe_number(counter_meta.curiosity_bonus_multiplier, 1.0) end
            action.curiosity_reason = reason
            score = score + bonus * cm
        end

        if bottleneck_val > 0 then
            if active_bottleneck == "alloys" and action.type == "build" and action.target == "alloy_foundry" then score = score + 0.10 end
            if active_bottleneck == "tech_tier" and action.type == "research" and action.target == "military_tech" then score = score + 0.10 end
            if active_bottleneck == "naval_cap" and action.type == "seal_borders" then score = score + 0.06 end
            if active_bottleneck == "influence" and action.type == "delay_stockpile" then score = score + 0.04 end
        end

        local base_margin = safe_number((self.config.strategic or {}).action_advantage_margin, 0.06)
        local uncertainty_margin = normalize_ratio(state.intel_uncertainty) * 0.05
        local crisis_margin = normalize_ratio(state.crisis_proximity) * 0.05
        local empire_scale_margin = math.min(0.08, safe_number(state.empire_size, 0) * 0.0005)
        local eta_press = (crisis_eta < 18) and -0.03 or 0
        local margin = base_margin + uncertainty_margin + crisis_margin + empire_scale_margin + eta_press
        if action.type ~= "delay_stockpile" and score < (wait_score + margin) then
            self:record_decision_why(action, "Trajectory fail: delay dominates future", state)
            goto continue
        end

        if score > best_score then
            best_score = score
            best_action = action
            if in_friend_mode then
                self:record_decision_why(action, "Selected by friend-support trajectory", state)
            else
                local meta_name = active_meta and active_meta.strategy_name or "none"
                self:record_decision_why(action, "Selected by campaign trajectory with survivable present (meta=" .. tostring(meta_name) .. ")", state)
            end
        end

        ::continue::
    end

    if not best_action then
        return { type = "delay_stockpile" }, wait_score
    end

    local notices = {}
    if in_friend_mode and best_action then
        notices = self:friend_mode_notices(state, best_action, player_intent)
        self.friend_state.notices = notices
        if best_action.type == "intercept_threat" or best_action.type == "evacuation_guard" then
            self.friend_state.rescue_cooldown = 4
        else
            self.friend_state.rescue_cooldown = math.max(0, safe_number(self.friend_state.rescue_cooldown, 0) - 1)
        end
    else
        self.friend_state.notices = {}
        self.friend_state.rescue_cooldown = math.max(0, safe_number(self.friend_state.rescue_cooldown, 0) - 1)
    end

    return best_action, best_score
end

-- ############################################################
-- 6) EVENTS + ANOMALIES + MEGASTRUCTURES
-- ############################################################

local HIGH_RISK_EVENT_KEYS = {
    shroud = true,
    dimensional_portal = true,
    worm = true,
    horizon_signal = true
}

function StratAI:choose_event_option(event, empire)
    local hostile_fleet = safe_number(event.hostile_fleet_power, 0)
    local own_fleet = safe_number(empire.fleet_power, 0)

    if event.key and HIGH_RISK_EVENT_KEYS[event.key] then
        if own_fleet >= hostile_fleet * 1.25 then
            return "accept", "High-risk event allowed only while strong"
        end
        return "delay", "High-risk event deferred"
    end

    local reward = event.permanent_modifier or event.tech_unlock or event.relic_reward
    if reward and own_fleet >= hostile_fleet then
        return "accept", "Rewarded event accepted"
    end

    if reward and hostile_fleet > own_fleet then
        return "delay", "Reward high but threat currently too high"
    end

    if event.category == "existential_threat" then
        return "refuse", "Existential event rejected"
    end

    return "accept", "Default safe acceptance"
end

function StratAI:should_research_anomaly(anomaly, scientist, game_phase)
    local difficulty = safe_number(anomaly.difficulty, 0)
    local skill = safe_number(scientist.skill, 1)

    if difficulty > skill + 1 then
        return false, "Skip: exceeds safe skill threshold"
    end

    if game_phase == PHASE.EARLY then
        if anomaly.precursor_related then return true, "Early precursor priority" end
        if difficulty <= skill then return true, "Early low-risk anomaly" end
        return false, "Early survey tempo priority"
    end

    if game_phase == PHASE.MID then
        return true, "Mid backlog cleanup"
    end

    if anomaly.has_relic or anomaly.strategic_resource or anomaly.unique_modifier then
        return true, "Late high-value anomaly only"
    end

    return false, "Late low-value anomalies ignored"
end

function StratAI:should_start_megastructure(empire)
    local stable = empire.economy_stable == true
    local alloy_surplus = safe_number(empire.alloy_surplus_monthly, 0)
    local cap_near_max = safe_number(empire.naval_cap_used_ratio, 0) >= 0.85
    return stable and alloy_surplus >= self.config.megastructure_alloy_surplus_floor and cap_near_max
end

function StratAI:next_megastructure(empire)
    if not self:should_start_megastructure(empire) then
        return nil, "Megastructure gate not passed"
    end

    if empire.currently_building_megastructure then
        return nil, "Already building one megastructure"
    end

    local built = empire.built_megastructures or {}
    for _, name in ipairs(MEGASTRUCTURE_PRIORITY) do
        if not built[name] then
            if name == "Ring World" and not built["Dyson Sphere"] then
                -- Do not build Ring World before energy solved.
            else
                return name, "Priority-selected megastructure"
            end
        end
    end

    return nil, "No pending megastructure choice"
end

-- ############################################################
-- 7) FAILURE MODES + MAIN LOOP
-- ############################################################

function StratAI:detect_failure_modes(empire)
    local failures = {}

    if safe_number(empire.low_habitability_colonies, 0) >= 3 then
        failures[#failures + 1] = "Over-colonizing low-habitability worlds"
    end
    if empire.mixed_role_planets then
        failures[#failures + 1] = "Mixed-role planet sprawl"
    end
    if safe_number(empire.housing_deficit_worlds, 0) > 0 then
        failures[#failures + 1] = "Housing/amenities ignored"
    end
    if empire.early_city_spam then
        failures[#failures + 1] = "Overbuilt city districts early"
    end
    if empire.megastructure_started_without_surplus then
        failures[#failures + 1] = "Megastructure start without alloy surplus"
    end
    if empire.auto_clicked_anomalies then
        failures[#failures + 1] = "Auto-clicked anomaly queue"
    end
    if safe_number(empire.consumer_goods, 0) <= 0 then
        failures[#failures + 1] = "Consumer goods collapse"
    end

    return failures
end

function StratAI:observe_state(raw_state)
    local state = deep_copy(raw_state or {})
    state.crisis_phase = state.crisis_phase or "none"
    state.crisis_type = state.crisis_type or "other"
    state.crisis_proximity = normalize_ratio(state.crisis_proximity)
    state.crisis_fleet_power = safe_number(state.crisis_fleet_power, 0)
    state.crisis_killer = state.crisis_killer
    state.our_power = safe_number(state.our_power, 0)
    state.enemy_crisis_fleet_ratio = normalize_ratio(state.enemy_crisis_fleet_ratio)
    state.crisis_strength = normalize_ratio(state.crisis_strength)
    state.arc_emitter_tech_unlocked = state.arc_emitter_tech_unlocked == true
    state.pd_tech_unlocked = state.pd_tech_unlocked == true
    state.tracking_tech_unlocked = state.tracking_tech_unlocked == true
    state.strike_craft_tech_unlocked = state.strike_craft_tech_unlocked == true
    state.game_year = safe_number(state.game_year, safe_number(state.year, 2300))
    state.bio_ascension = state.bio_ascension == true
    state.machine_age_virtuality = state.machine_age_virtuality == true
    state.shattered_ring_origin = state.shattered_ring_origin == true
    state.enemy_bio_ascension = state.enemy_bio_ascension == true
    state.enemy_machine_age_virtuality = state.enemy_machine_age_virtuality == true
    state.enemy_shattered_ring_origin = state.enemy_shattered_ring_origin == true
    state.pop_growth_pressure = normalize_ratio(state.pop_growth_pressure)
    state.enemy_pop_growth_pressure = normalize_ratio(state.enemy_pop_growth_pressure)
    state.planet_capacity_pressure = normalize_ratio(state.planet_capacity_pressure)
    state.alloy_density = normalize_ratio(state.alloy_density)
    state.federation_opportunity = normalize_ratio(state.federation_opportunity)
    state.our_active_fronts = safe_number(state.our_active_fronts, 1)
    state.ethics = state.ethics or {}
    state.civics = state.civics or {}
    state.disable_xeno_compat = state.disable_xeno_compat == true
    state.disable_eternal_vigilance = state.disable_eternal_vigilance == true
    return state
end

function StratAI:update_models(observation)
    self:update_galaxy_meta(observation.galaxy_meta or {})

    for enemy_id, data in pairs(observation.enemy_observations or {}) do
        self:update_opponent_model(enemy_id, data)
        self:update_enemy_mind_model(enemy_id, {
            risk_tolerance = data.risk_tolerance,
            overreact = data.overreact,
            turtle = data.turtle,
            bad_war_accept = data.bad_war_accept
        })
    end

    if observation.primary_rival and self.enemy_models[observation.primary_rival] then
        observation.counter_score = self:compute_counter_score(
            observation.our_fleet_vector or {},
            self.enemy_models[observation.primary_rival]
        )
    else
        observation.counter_score = safe_number(observation.counter_score, 0)
    end

    observation.player_profile = self:update_player_profile(observation)
    self:update_strategic_memory(observation)
    return observation
end

function StratAI:commit_action(action)
    self.current_plan = action
    return action
end


function StratAI:compute_priority_queue(state, phase)
    local b = self:_phase_priority_bias(phase)
    local queue = {
        { key = "economy", value = math.max(0, -safe_number(state.net_consumer_goods, 0)) * 2 + math.max(0, -safe_number(state.net_energy, 0)) },
        { key = "stability", value = math.max(0, 50 - safe_number(state.avg_planet_stability, 50)) + safe_number(state.revolt_risk, 0) * 30 },
        { key = "military", value = safe_number(state.hostile_neighbors_ratio, 0) * 20 + safe_number(state.crisis_proximity, 0) * 25 },
        { key = "tech", value = math.max(0, safe_number(self.galaxy_meta.avg_tech_tier, 1) - safe_number(state.tech_tier, 1)) * 12 }
    }

    for _, item in ipairs(queue) do
        item.value = item.value * safe_number(b[item.key], 1)
    end

    table.sort(queue, function(a, b2) return a.value > b2.value end)
    return queue
end

function StratAI:panic_guardrails(state, action)
    local break_window = state.rule_break_window == true

    if action.type == "declare_war" then
        if safe_number(state.net_consumer_goods, 0) < 0 and not break_window then
            return false, "Panic guard: no war during CG deficit"
        end
        if safe_number(state.avg_planet_stability, 50) < 45 and not break_window then
            return false, "Panic guard: no war while unstable"
        end
    end

    if action.type == "redesign_fleet" and state.at_war and not break_window then
        return false, "Panic guard: reinforce during war, avoid full redesign"
    end

    return true, "Action passes panic guard"
end

function StratAI:uncertainty_adjusted_score(score, state)
    local intel_uncertainty = safe_number(state.intel_uncertainty, 0)
    local damp = clamp(1.0 - intel_uncertainty * self.config.risk_uncertainty_penalty * 2.0, 0.7, 1.0)
    return score * damp
end

-- Compatibility aliases mirroring the fighting-game loop names.
function StratAI:sense(raw_state)
    return self:observe_state(raw_state)
end

function StratAI:update_model(observation)
    return self:update_models(observation)
end

function StratAI:generate_options(state)
    return self:generate_actions(state)
end

function StratAI:evaluate(state, phase)
    return self:evaluate_state(state, phase)
end

function StratAI:commit(action)
    return self:commit_action(action)
end

function StratAI:tick(raw_observation)
    -- Main control loop:
    -- observe_state -> update_opponent_model -> generate_actions -> simulate_shallow -> evaluate -> commit_action
    local state = self:observe_state(raw_observation)
    state = self:update_models(state)
    self:_update_metric_history(state)

    for enemy_id, c in pairs(self.doctrine_cooldowns or {}) do
        for d, v in pairs(c) do
            c[d] = math.max(0, safe_number(v, 0) - 1)
        end
        self.doctrine_cooldowns[enemy_id] = c
    end

    local phase = state.phase or PHASE.MID
    local perf = self.config.performance or {}
    local low_diff = safe_number(state.difficulty, 1.0) < safe_number(perf.low_difficulty_threshold, 0.65)
    if low_diff then
        state.projection_month_cap = safe_number(perf.max_projection_months_low_diff, 24)
    end
    state.failure_clocks = self:estimate_failure_clocks(state)
    state.identity = self:update_empire_identity(state)
    state.windows = self:window_model(state)
    state.bottleneck, state.bottleneck_value, state.bottleneck_map = self:detect_bottleneck(state)
    state.active_bottleneck = self:update_bottleneck_override(state)
    state.effective_game_over, state.closure_confidence = self:effective_game_over(state)
    state.rule_break_window = self:rule_break_window(state)
    state.priority_queue = self:compute_priority_queue(state, phase)
    if (self.config.compatibility or {}).disable_xeno_compat_opt_in then state.disable_xeno_compat = true end
    if (self.config.compatibility or {}).disable_eternal_vigilance_opt_in then state.disable_eternal_vigilance = true end

    if state.primary_rival then
        state.recommended_doctrine, state.doctrine_reason = self:recommend_doctrine(state.primary_rival)

        local rival_model = self.enemy_models[state.primary_rival] or {}
        local cc = ((self.clausewitz_memory.confidence_counters or {})[state.primary_rival] or { value = 0 })
        local doctrine_conf = safe_number(cc.value, 0)

        self.active_counter_meta = nil
        self.opponent_meta_confidence = 0
        local highest_conf = 0
        for _, entry in ipairs(COUNTER_META_TABLE) do
            if doctrine_conf >= 3 and self:matches_counter_meta_conditions(entry, state, rival_model) then
                local conf = safe_number(entry.confidence, 0.5) * clamp(doctrine_conf / 8.0, 0, 1)
                if conf > highest_conf then
                    highest_conf = conf
                    self.active_counter_meta = entry
                    self.opponent_meta_confidence = conf
                end
            end
        end
    else
        self.active_counter_meta = nil
        self.opponent_meta_confidence = 0
    end

    state.curiosity_enabled, state.curiosity_meta = self:curiosity_mode(state)
    state.campaign_plan = self.campaign_memory.active_plan
    state.player_archetype = (self.player_profile or {}).archetype
    state.friend_notices = deep_copy((self.friend_state or {}).notices or {})
    state.galactic_collapse_eta = self:galactic_collapse_eta(state)
    state.active_meta_strategy = self.strongest_meta and self.strongest_meta.strategy_name or "none"
    state.active_counter_meta_strategy = self.active_counter_meta and self.active_counter_meta.our_strategy_name or "none"
    state.opponent_detected = self.active_counter_meta and "Meta spammer countered" or "No counter needed"

    local action, score = self:select_best_action(state, phase)
    state.eval_explain = self:explain_eval_snapshot(state)

    if not action then
        action = { type = "delay_stockpile" }
        score = self:evaluate_state(state, phase)
    end

    self:commit_action(action)
    if self:is_exploratory_action(action) then
        self:decay_curiosity_domain(self:curiosity_domain(action))
    else
        self:refresh_curiosity_domains()
    end
    state.self_critique = self:self_critique(state)
    state.domain_confidence = self:update_domain_confidence(state)
    self:update_meta_learning(state, action, score)
    self:_update_meta_effectiveness(state.active_meta_strategy, state.active_counter_meta_strategy, score)
    state.last_eval_components = self:_log_eval_components(state)
    return action, score, self.last_eval
end

return StratAI
